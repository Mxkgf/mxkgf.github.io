<!DOCTYPE html>
<html lang="zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mxkgf.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天行健，君子以自强不息">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://mxkgf.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="天行健，君子以自强不息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="马晓康">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://mxkgf.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh_CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-日程表"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-站点地图"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-公益404"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益404</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">马晓康</p>
  <div class="site-description" itemprop="description">天行健，君子以自强不息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mxkgf" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mxkgf" rel="noopener me" target="_blank">GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mxkgf.github.io/2024/04/14/readme/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="马晓康">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/14/readme/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-04-14 11:44:28 / Modified: 11:44:45" itemprop="dateCreated datePublished" datetime="2024-04-14T11:44:28+08:00">2024-04-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Omnifood"><a href="#Omnifood" class="headerlink" title="Omnifood"></a>Omnifood</h1><h2 id="About-Omnifood"><a href="#About-Omnifood" class="headerlink" title="About Omnifood"></a>About Omnifood</h2><p>We are a technology company first, but with a major focus on consumer well-being through a healthy diet. Most people are very busy with their jobs, family and friends, and other important activities, which doesn’t leave much time for cooking. This might lead to a poor diet and lasting health consequences. We want to solve this problem by using an AI-centric approach. Users can use our app to select their diet and foods they like and dislike, and our AI algorithm will create a custom and individual weekly meal plan. But we don’t stop there. We partner with restaurants and other cooking partners to actually cook and deliver all meals from the generated meal plans, in selected cities. All this will be packed up in a monthly subscription, where users can choose between receiving one or two meals per day, every single day of the month.</p>
<h2 id="Branding"><a href="#Branding" class="headerlink" title="Branding"></a>Branding</h2><p>Headline: A healthy meal delivered to your door, every single day</p>
<p>Brand color: #e67e22</p>
<h2 id="Omnifood-Website-Content"><a href="#Omnifood-Website-Content" class="headerlink" title="Omnifood Website Content"></a>Omnifood Website Content</h2><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>The smart 365-days-per-year food subscription that will make you eat healthy again. Tailored to your personal tastes and nutritional needs. We have delivered 250,000+ meals last year!</p>
<h3 id="Omnifood-features"><a href="#Omnifood-features" class="headerlink" title="Omnifood features"></a>Omnifood features</h3><p>Never cook again!: Our subscriptions cover 365 days per year, even including major holidays.<br>Local and organic: Our cooks only use local, fresh, and organic products to prepare your meals.<br>No waste: All our partners only use reusable containers to package all your meals.<br>Pause anytime: Going on vacation? Just pause your subscription, and we refund unused days.</p>
<h3 id="How-Omnifood-works"><a href="#How-Omnifood-works" class="headerlink" title="How Omnifood works"></a>How Omnifood works</h3><p>[Show big app images]</p>
<p><strong>Your daily dose of health in 3 simple steps</strong></p>
<p>Tell us what you like (and what not): Never again waste time thinking about what to eat! Omnifood AI will create a 100% personalized weekly meal plan just for you. It makes sure you get all the nutrients and vitamins you need, no matter what diet you follow!</p>
<p>Approve your weekly meal plan: Once per week, approve the meal plan generated for you by Omnifood AI. You can change ingredients, swap entire meals, or even add your own recipes.</p>
<p>Receive meals at convenient time: Best chefs in town will cook your selected meal every day, and we will deliver it to your door whenever works best for you. You can change delivery schedule and address daily!</p>
<h3 id="Omnifood-works-with-any-diet"><a href="#Omnifood-works-with-any-diet" class="headerlink" title="Omnifood works with any diet"></a>Omnifood works with any diet</h3><p>Vegetarian<br>Vegan<br>Pescatarian<br>Gluten-free<br>Lactose-free<br>Keto<br>Paleo<br>Low FODMAP<br>Kid-friendly</p>
<h3 id="Sample-meals"><a href="#Sample-meals" class="headerlink" title="Sample meals"></a>Sample meals</h3><p><strong>Omnifood AI chooses from 5,000+ recipes</strong></p>
<p>Meal 1: Japanese Gyozas</p>
<ul>
<li>Category: Vegetarian</li>
<li>Calories: 650</li>
<li>NutriScore (Registered): 74</li>
<li>Average rating: 4.9</li>
<li>Number reviews: 537</li>
</ul>
<p>Meal 2: Avocado Salad</p>
<ul>
<li>Category: Vegan and Paleo</li>
<li>Calories: 400</li>
<li>NutriScore (Registered): 92</li>
<li>Average rating: 4.8</li>
<li>Number reviews: 441</li>
</ul>
<h3 id="We-offer-a-free-sample-meal"><a href="#We-offer-a-free-sample-meal" class="headerlink" title="We offer a free sample meal"></a>We offer a free sample meal</h3><p>[Create simple form for users to sign up]</p>
<p>Healthy, tasty and hassle-free meals are waiting for you. Start eating well today. You can cancel or pause anytime. And the first meal is on us!</p>
<h3 id="We-have-2-pricing-plans"><a href="#We-have-2-pricing-plans" class="headerlink" title="We have 2 pricing plans"></a>We have 2 pricing plans</h3><p>Prices include all applicable taxes. Users can cancel at any time.</p>
<p>Starter: $399 per month</p>
<ul>
<li>1 meal per day</li>
<li>Order times are between 11am and 9pm</li>
<li>Delivery is free</li>
</ul>
<p>Complete: $649 per month</p>
<ul>
<li>2 meal2 per day</li>
<li>Order 24/7</li>
<li>Delivery is free</li>
<li>Get access to latest recipes</li>
</ul>
<h3 id="Photo-gallery"><a href="#Photo-gallery" class="headerlink" title="Photo gallery"></a>Photo gallery</h3><p>[Use the 12 photos we provided]</p>
<h3 id="Customer-testimonials"><a href="#Customer-testimonials" class="headerlink" title="Customer testimonials"></a>Customer testimonials</h3><p>[Photos of customers included]</p>
<p>Inexpensive, healthy and great-tasting meals, without even having to order manually! It feels truly magical. (Dave Bryson)<br>The AI algorithm is crazy good, it chooses the right meals for me every time. It’s amazing not to worry about food anymore! (Ben Hadley)<br>Omnifood is a life saver! I just started a company, so there’s no time for cooking. I couldn’t live without my daily meals now! (Steve Miller)<br>I got Omnifood for the whole family, and it frees up so much time! Plus, everything is organic and vegan and without plastic. (Hannah Smith)</p>
<h3 id="Section-with-logos-of-featured-publications-see-images"><a href="#Section-with-logos-of-featured-publications-see-images" class="headerlink" title="Section with logos of featured publications [see images]"></a>Section with logos of featured publications [see images]</h3><h3 id="Contact-information"><a href="#Contact-information" class="headerlink" title="Contact information"></a>Contact information</h3><p>Address: 623 Harrison St., 2nd Floor, San Francisco, CA 94107<br>Phone: 415-201-6370<br>Email: hello@omnifood.com</p>
<p>Social profiles: instagram, facebook, twitter [links to them not available yet]</p>
<h3 id="Additional-links-links-not-available-yet"><a href="#Additional-links-links-not-available-yet" class="headerlink" title="Additional links [links not available yet]"></a>Additional links [links not available yet]</h3><p>Create account<br>Sign in<br>iOS app<br>Android app<br>About Omnifood<br>For Business<br>Cooking partners<br>Careers<br>Recipe directory<br>Help center<br>Privacy &amp; terms</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mxkgf.github.io/2024/04/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="马晓康">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面向对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-08 06:49:00" itemprop="dateCreated datePublished" datetime="2024-04-08T06:49:00+08:00">2024-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-04-10 18:08:26" itemprop="dateModified" datetime="2024-04-10T18:08:26+08:00">2024-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向对象编程（OOP）是一种组织程序的方法，它将本章介绍的许多思想集合在一起。类似于数据抽象中的函数，类创建了在使用和实现数据之间的抽象屏障。类似于分派字典，对象响应行为请求。类似于可变数据结构，对象具有不直接从全局环境访问的局部状态。Python 对象系统提供了方便的语法，以促进使用这些技术来组织程序。这些语法在其他面向对象编程语言中也是共享的。</p>
<p>对象系统提供的不仅仅是方便。它为在计算机内部设计程序提供了一种新的隐喻，其中有几个独立的代理在相互作用。每个对象将本地状态和行为捆绑在一起，以一种抽象了两者复杂性的方式。对象彼此通信，并且有用的结果是作为它们相互作用的结果计算出来的。对象不仅传递消息，还与同一类型的其他对象共享行为，并从相关类型继承特性。</p>
<p>面向对象编程范式具有支持对象隐喻的专有词汇。我们已经看到，对象是具有方法和属性的数据值，可以通过点符号访问。每个对象还有一个称为类的类型。为了创建新类型的数据，我们实现新的类。</p>
<h3 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h3><p>类作为所有类型为该类的对象的模板。每个对象都是某个特定类的实例。到目前为止，我们使用的对象都有内置的类，但也可以创建新的用户定义类。类定义指定了该类的对象之间共享的属性和方法。我们将通过重新访问银行账户的示例来介绍类语句。</p>
<p>当引入本地状态时，我们发现银行账户自然地被建模为具有 <code>balance</code> 的可变值。银行账户对象应该有一个 <code>withdraw</code> 方法，用于更新账户余额并返回请求的金额（如果可用）。为了完成抽象：银行账户应该能够返回其当前的 <code>balance</code> ，返回账户 <code>holder</code> 的名称，并返回 <code>deposit</code> 的金额。</p>
<p>一个 <code>Account</code> 类允许我们创建多个银行账户实例。创建一个新的对象实例的行为被称为实例化类。在 Python 中，实例化类的语法与调用函数的语法相同。在这种情况下，我们使用参数 <code>&#39;Kirk&#39;</code> 调用 <code>Account</code> ，即账户持有人的姓名。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Account(<span class="string">&#x27;Kirk&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>对象的属性是与对象关联的名称-值对，可以通过点表示法访问。与类的所有对象相对应的特定对象的属性称为实例属性。每个 <code>Account</code> 都有自己的余额和账户持有人姓名，这些是实例属性的示例。在更广泛的编程社区中，实例属性也可以称为字段、属性或实例变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.holder</span><br><span class="line"><span class="string">&#x27;Kirk&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.balance</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>对对象进行操作或执行特定于对象的计算的函数称为方法。方法的返回值和副作用可能依赖于并改变对象的其他属性。例如， <code>deposit</code> 是我们的 <code>Account</code> 对象 <code>a</code> 的一个方法。它接受一个参数，即要存入的金额，改变对象的 <code>balance</code> 属性，并返回结果余额。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.deposit(<span class="number">15</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>我们说方法是在特定对象上调用的。通过调用 <code>withdraw</code> 方法，要么批准提款并扣除金额，要么拒绝请求并返回错误消息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.withdraw(<span class="number">10</span>)  <span class="comment"># The withdraw method returns the balance after withdrawal</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.balance       <span class="comment"># The balance attribute has changed</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.withdraw(<span class="number">10</span>)</span><br><span class="line"><span class="string">&#x27;Insufficient funds&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如上所示，方法的行为可以取决于对象的可变属性。对于相同的参数，两次调用 <code>withdraw</code> 会返回不同的结果。</p>
<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>用户定义的类是通过 <code>class</code> 语句创建的，该语句由一个单独的子句组成。类语句定义了类名，然后包含一系列语句来定义类的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;name&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>
<p>当执行一个类语句时，会创建一个新的类并绑定到当前环境的第一个帧中的 <code>&lt;name&gt;</code> 。然后执行套件。通过 <code>def</code> 或赋值语句在 <code>class</code> 语句的 <code>&lt;suite&gt;</code> 中绑定的任何名称都会创建或修改类的属性。</p>
<p>类通常围绕着操作实例属性进行组织，实例属性是与该类的每个实例关联的名称-值对。通过定义一个初始化新对象的方法，类指定了其对象的实例属性。例如，初始化 <code>Account</code> 类的对象的一部分是将其起始余额设为0。</p>
<p>一个 <code>&lt;suite&gt;</code> 语句的 <code>class</code> 包含 <code>def</code> 语句，用于为该类的对象定义新的方法。在Python中，初始化对象的方法有一个特殊的名称 <code>__init__</code> （单词”init”两边各有两个下划线），被称为该类的构造函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br></pre></td></tr></table></figure>
<p><code>__init__</code> 方法对 <code>Account</code> 有两个形式参数。第一个参数 <code>self</code> 绑定到新创建的 <code>Account</code> 对象。第二个参数 <code>account_holder</code> 绑定到在实例化类时传递的参数。</p>
<p>构造函数将实例属性名称 <code>balance</code> 绑定到 0。它还将属性名称 <code>holder</code> 绑定到名称 <code>account_holder</code> 的值。形式参数 <code>account_holder</code> 是 <code>__init__</code> 方法中的局部名称。另一方面，通过最终赋值语句绑定的名称 <code>holder</code> 会持续存在，因为它以点表示法存储为 <code>self</code> 的属性。</p>
<p>构造函数将实例属性名称 <code>balance</code> 绑定到 0。它还将属性名称 <code>holder</code> 绑定到名称 <code>account_holder</code> 的值。形式参数 <code>account_holder</code> 是 <code>__init__</code> 方法中的局部名称。另一方面，通过最终赋值语句绑定的名称 <code>holder</code> 会持续存在，因为它以点表示法存储为 <code>self</code> 的属性。</p>
<p>对 <code>Account</code> 类的这个“调用”创建了一个新对象，该对象是 <code>Account</code> 的一个实例，然后使用两个参数调用构造函数 <code>__init__</code> ：新创建的对象和字符串 <code>&#39;Kirk&#39;</code> 。按照惯例，我们在构造函数的第一个参数使用参数名称 <code>self</code> ，因为它绑定到正在实例化的对象。这个惯例在几乎所有的 Python 代码中都被采用。<br>现在，我们可以使用点表示法访问对象的 <code>balance</code> 和 <code>holder</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.balance</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.holder</span><br><span class="line"><span class="string">&#x27;Kirk&#x27;</span></span><br></pre></td></tr></table></figure>
<p>身份。每个新的账户实例都有自己的余额属性，其值与同一类的其他对象无关。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Account(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.balance = <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[acc.balance <span class="keyword">for</span> acc <span class="keyword">in</span> (a, b)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">200</span>]</span><br></pre></td></tr></table></figure>
<p>为了强制实现这种分离，每个属于用户定义类的对象都有唯一的身份。对象的身份是通过使用 <code>is</code> 和 <code>is not</code> 运算符进行比较的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> <span class="keyword">not</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>尽管由相同的调用构建，绑定到 <code>a</code> 和 <code>b</code> 的对象并不相同。通常情况下，使用赋值将对象绑定到新名称并不会创建一个新对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>当使用调用表达式语法实例化类（例如 <code>Account</code> ）时，只有具有用户定义类的新对象才会被创建。</p>
<p>方法。对象方法也是在 <code>class</code> 语句的代码块中通过 <code>def</code> 语句来定义的。下面， <code>deposit</code> 和 <code>withdraw</code> 都被定义为 <code>Account</code> 类的对象的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br></pre></td></tr></table></figure>
<p>虽然方法定义在声明方式上与函数定义没有区别，但是当执行时，方法定义会产生不同的效果。在类内部，通过在语句中使用 <code>def</code> 语句创建的函数值会绑定到声明的名称上，但是作为属性在类内部局部绑定。可以使用点符号从类的实例中调用该值作为方法。</p>
<p>每个方法定义都包括一个特殊的第一个参数 <code>self</code> ，它绑定到调用该方法的对象上。例如，假设 <code>deposit</code> 在特定的 <code>Account</code> 对象上调用，并传递一个单一的参数值：存款金额。对象本身绑定到 <code>self</code>，而参数绑定到 <code>amount</code> 。所有调用的方法都可以通过 <code>self</code> 参数访问对象，因此它们都可以访问和操作对象的状态。</p>
<p>要调用这些方法，我们再次使用点表示法，如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account = Account(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.deposit(<span class="number">100</span>)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.withdraw(<span class="number">90</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.withdraw(<span class="number">90</span>)</span><br><span class="line"><span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.holder</span><br><span class="line"><span class="string">&#x27;Spock&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当通过点表示法调用一个方法时，对象本身（在这种情况下绑定到 <code>spock_account</code> ）扮演着双重角色。首先，它确定了名称 <code>withdraw</code> 的含义； <code>withdraw</code> 不是环境中的名称，而是 <code>Account</code> 类中的局部名称。其次，在调用 <code>withdraw</code> 方法时，它绑定到第一个参数 <code>self</code> 。</p>
<h3 id="消息传递和点表达式"><a href="#消息传递和点表达式" class="headerlink" title="消息传递和点表达式"></a>消息传递和点表达式</h3><p>方法是在类中定义的，实例属性通常在构造函数中赋值，它们是面向对象编程的基本元素。这两个概念在数据值的消息传递实现中复制了调度字典的大部分行为。对象使用点表示法接收消息，但这些消息不是任意的字符串键，而是类内部的名称。对象还具有命名的本地状态值（实例属性），但可以使用点表示法访问和操作该状态，而无需在实现中使用语句。</p>
<p>消息传递的核心理念是，数据值应该通过响应与其所代表的抽象类型相关的消息来表现出行为。点表示法是 Python 的一种语法特性，形式化了消息传递的隐喻。使用内置对象系统的语言的优势在于，消息传递可以与其他语言特性（如赋值语句）无缝交互。我们不需要不同的消息来“获取”或“设置”与局部属性名关联的值；语言语法允许我们直接使用消息名称。</p>
<p><strong>点表达式</strong>。代码片段 <code>spock_account.deposit</code> 称为点表达式。点表达式由表达式、点和名称组成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; . &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;expression&gt;</code> 可以是任何有效的 Python 表达式，但 <code>&lt;name&gt;</code> 必须是一个简单名称（而不是求值为名称的表达式）。点表达式求值为具有给定 <code>&lt;name&gt;</code> 的属性值，对于值为 <code>&lt;expression&gt;</code> 的对象。</p>
<p>内置函数 <code>getattr</code> 也按名称返回对象的属性。它是点表示法的函数等价物。使用 <code>getattr</code> ，我们可以使用字符串查找属性，就像我们在分派字典中所做的一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(spock_account, <span class="string">&#x27;balance&#x27;</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用 <code>hasattr</code> 来测试一个对象是否具有指定的属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(spock_account, <span class="string">&#x27;deposit&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>对象的属性包括其所有实例属性，以及其类中定义的所有属性（包括方法）。方法是类的属性，需要特殊处理。</p>
<p><strong>方法和函数</strong>。当在对象上调用方法时，该对象会隐式地作为方法的第一个参数传递。也就是说，点号左侧的对象的值会自动作为点号右侧表达式中命名的方法的第一个参数传递。因此，对象会绑定到参数 <code>self</code> 。</p>
<p>为了实现自动的 <code>self</code> 绑定，Python 区分了函数（我们从文本开始就一直在创建）和绑定方法。绑定方法将函数和将要调用该方法的对象耦合在一起。绑定方法的值已经与其第一个参数关联，即调用该方法时的实例，该实例将在调用方法时命名为 <code>self</code> 。</p>
<p>我们可以通过调用点表达式的返回值上的 <code>type</code> 来看到交互式解释器中的差异。作为类的属性，方法只是一个函数，但作为实例的属性，它是一个绑定方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(spock_account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;method&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这两个结果只在于第一个是一个具有参数 <code>self</code> 和 <code>amount</code> 的标准二参数函数，第二个则是一个一参数方法，在调用方法时名称 <code>self</code> 将自动绑定到名为 <code>spock_account</code> 的对象，而参数 <code>amount</code> 将绑定到传递给方法的参数。这两个值，无论是函数值还是绑定的方法值，都与相同的 <code>deposit</code> 函数体相关。</p>
<p>我们可以用两种方式调用 <code>deposit</code> ：作为函数和作为绑定方法。在前一种情况下，我们必须明确地为 <code>self</code> 参数提供一个参数。在后一种情况下， <code>self</code> 参数会自动绑定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.deposit(spock_account, <span class="number">1001</span>)  <span class="comment"># The deposit function takes 2 arguments</span></span><br><span class="line"><span class="number">1011</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.deposit(<span class="number">1000</span>)           <span class="comment"># The deposit method takes 1 argument</span></span><br><span class="line"><span class="number">2011</span></span><br></pre></td></tr></table></figure>
<p>函数 <code>getattr</code> 的行为与点符号表示法完全相同：如果它的第一个参数是对象，但名称是在类中定义的方法，则 <code>getattr</code> 返回一个绑定的方法值。另一方面，如果第一个参数是一个类，则 <code>getattr</code> 直接返回属性值，这是一个普通函数。</p>
<p><strong>命名约定</strong>。类名通常使用 CapWords 约定进行书写（也称为驼峰命名，因为名称中间的大写字母看起来像驼峰）。方法名遵循使用下划线分隔的小写单词命名函数的标准约定。</p>
<p>在某些情况下，存在与对象的维护和一致性相关的实例变量和方法，我们不希望对象的用户看到或使用它们。它们不是类定义的抽象的一部分，而是实现的一部分。Python的约定规定，如果属性名称以下划线开头，应该只在类自身的方法中访问，而不是类的用户访问。</p>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>某些属性值在给定类的所有对象之间共享。这些属性与类本身相关联，而不是与类的任何个体实例相关联。例如，假设银行按固定利率支付账户余额的利息。该利率可能会变化，但它是所有账户共享的单一值。</p>
<p>类属性是通过赋值语句在 <code>class</code> 语句的套件中创建的，在任何方法定义之外。在更广泛的开发者社区中，类属性也可能被称为类变量或静态变量。以下类语句创建了一个名为 <code>interest</code> 的 <code>Account</code> 类属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        interest = <span class="number">0.02</span>            <span class="comment"># A class attribute</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="comment"># Additional methods would be defined here</span></span><br></pre></td></tr></table></figure>
<p>这个属性仍然可以从类的任何实例中访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account = Account(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account = Account(<span class="string">&#x27;Kirk&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.02</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.02</span></span><br></pre></td></tr></table></figure>
<p>然而，对类属性的单个赋值语句会改变该属性在类的所有实例中的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.interest = <span class="number">0.04</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br></pre></td></tr></table></figure>
<p><strong>属性名称</strong>。我们在对象系统中引入了足够的复杂性，以至于我们必须指定名称如何解析为特定的属性。毕竟，我们很容易拥有一个类属性和一个实例属性具有相同的名称。</p>
<p>正如我们所见，点表达式由一个表达式、一个点和一个名称组成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression&gt; . &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>要评估一个点表达式：</p>
<ol>
<li>评估点号左侧的 <code>&lt;expression&gt;</code> ，得到点号表达式的对象。</li>
<li><code>&lt;name&gt;</code> 与该对象的实例属性进行匹配；如果存在具有该名称的属性，则返回其值。</li>
<li>如果 <code>&lt;name&gt;</code> 在实例属性中不存在，则在类中查找 <code>&lt;name&gt;</code> ，这将得到一个类属性值。</li>
<li>除非该值是一个函数，否则将返回该值，如果是函数，则返回一个绑定方法。</li>
</ol>
<p>在这个评估过程中，实例属性在类属性之前被找到，就像局部名称在环境中优先于全局名称一样。在类中定义的方法与点表达式的对象在这个评估过程的第四步中组合形成一个绑定方法。在类中查找名称的过程有一些额外的细微差别，一旦我们介绍类继承，这些差别将很快出现。</p>
<p><strong>属性赋值</strong>。所有包含点表达式的赋值语句都会影响该点表达式对象的属性。如果对象是一个实例，则赋值会设置实例属性。如果对象是一个类，则赋值会设置类属性。根据这个规则，对一个对象的属性进行赋值不会影响其类的属性。下面的例子说明了这个区别。</p>
<p>如果我们给账户实例的命名属性 <code>interest</code> 赋值，我们将创建一个与现有类属性同名的新实例属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest = <span class="number">0.08</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.08</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br></pre></td></tr></table></figure>
<p>对类属性 <code>interest</code> 的更改将影响 <code>spock_account</code> ，但实例属性 <code>kirk_account</code> 将不受影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.interest = <span class="number">0.05</span>  <span class="comment"># changing the class attribute</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest     <span class="comment"># changes instances without like-named instance attributes</span></span><br><span class="line"><span class="number">0.05</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest     <span class="comment"># but the existing instance attribute is unaffected</span></span><br><span class="line"><span class="number">0.08</span></span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在面向对象编程范式中，我们经常发现不同的类型之间存在关联。特别是，我们发现相似的类在其专业化程度上有所不同。两个类可能具有相似的属性，但其中一个表示另一个的特殊情况。</p>
<p>例如，我们可能想要实现一个支票账户，它与标准账户不同。支票账户每次取款都会额外收取 1 美元，并且利率较低。在这里，我们展示了所需的行为。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch = CheckingAccount(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.interest     <span class="comment"># Lower interest rate for checking accounts</span></span><br><span class="line"><span class="number">0.01</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.deposit(<span class="number">20</span>)  <span class="comment"># Deposits are the same</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.withdraw(<span class="number">5</span>)  <span class="comment"># withdrawals decrease balance by an extra charge</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>一个 <code>CheckingAccount</code> 是 <code>Account</code> 的一种特殊化。在面向对象编程术语中，通用账户将作为 <code>CheckingAccount</code> 的基类，而 <code>CheckingAccount</code> 将是 <code>Account</code> 的子类。（基类也可以用父类和超类来表示，而子类也可以用子类来表示。）</p>
<p>子类继承其基类的属性，但可以覆盖某些属性，包括某些方法。通过继承，我们只需指定子类与基类之间的差异。在子类中未指定的任何内容都会自动假定与基类的行为相同。</p>
<p>继承在我们的对象隐喻中也起着作用，除了作为一个有用的组织特性。继承的目的是表示类之间的是一个关系，与拥有关系相对应。支票账户是一种特定类型的账户，所以从一个账户继承是继承的适当用法。另一方面，银行有一个管理的银行账户列表，所以它们之间都不应该互相继承。相反，账户对象的列表自然地表达为银行对象的实例属性。</p>
<h3 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h3><p>首先，我们给出了 <code>Account</code> 类的完整实现，其中包括类和其方法的文档字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A bank account that has a non-negative balance.&quot;&quot;&quot;</span></span><br><span class="line">        interest = <span class="number">0.02</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Increase the account balance by amount and return the new balance.&quot;&quot;&quot;</span></span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Decrease the account balance by amount and return the new balance.&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br></pre></td></tr></table></figure>
<p>下面是 <code>CheckingAccount</code> 的完整实现。我们通过在类名后面的括号中放置一个求值为基类的表达式来指定继承关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">CheckingAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A bank account that charges for withdrawals.&quot;&quot;&quot;</span></span><br><span class="line">        withdraw_charge = <span class="number">1</span></span><br><span class="line">        interest = <span class="number">0.01</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">return</span> Account.withdraw(self, amount + self.withdraw_charge)</span><br></pre></td></tr></table></figure>
<p>在这里，我们引入了一个特定于 <code>CheckingAccount</code> 类的类属性 <code>withdraw_charge</code> 。我们给 <code>interest</code> 属性赋予了一个较低的值。我们还定义了一个新的 <code>withdraw</code> 方法来覆盖 <code>Account</code> 类中定义的行为。在类套件中没有进一步的语句时，所有其他行为都继承自基类 <code>Account</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking = CheckingAccount(<span class="string">&#x27;Sam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.deposit(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.withdraw(<span class="number">5</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.interest</span><br><span class="line"><span class="number">0.01</span></span><br></pre></td></tr></table></figure>
<p>表达式 <code>checking.deposit</code> 的求值结果是一个绑定方法，用于进行存款操作，该方法在 <code>Account</code> 类中定义。当 Python 在点表达式中解析一个不是实例属性的名称时，它会在类中查找该名称。实际上，“查找”一个类中的名称会尝试在原始对象的类的继承链中的每个基类中找到该名称。我们可以递归地定义这个过程。在类中查找一个名称。</p>
<ol>
<li>如果名称是类中的属性，则返回属性值。</li>
<li>否则，如果存在基类，则在基类中查找该名称。</li>
</ol>
<p>在 <code>deposit</code> 的情况下，Python首先会在实例中查找名称，然后在 <code>CheckingAccount</code> 类中查找。最后，它会在 <code>Account</code> 类中查找，其中定义了 <code>deposit</code> 。根据我们对点表达式的评估规则，由于 <code>deposit</code> 是在 <code>checking</code> 实例的类中查找的函数，点表达式的评估结果是一个绑定方法值。该方法使用参数10调用，这将使用 <code>self</code> 绑定到 <code>checking</code> 对象和 <code>amount</code> 绑定到10来调用存款方法。</p>
<p>对象的类在整个过程中保持不变。即使在 <code>deposit</code> 类中找到了 <code>Account</code> 方法， <code>deposit</code> 也是使用绑定到 <code>self</code> 的 <code>CheckingAccount</code> 实例进行调用，而不是 <code>Account</code> 的实例。</p>
<p><strong>调用祖先</strong>。通过类对象仍然可以访问已被覆盖的属性。例如，我们通过调用 <code>Account</code> 的 <code>withdraw</code> 方法并传入包含 <code>withdraw_charge</code> 的参数来实现 <code>CheckingAccount</code> 的 <code>withdraw</code> 方法。</p>
<p>注意，我们调用的是 <code>self.withdraw_charge</code> 而不是等效的 <code>CheckingAccount.withdraw_charge</code> 。前者相对于后者的好处是，继承自 <code>CheckingAccount</code> 的类可能会覆盖提取费用。如果是这种情况，我们希望我们的 <code>withdraw</code> 实现能找到新值而不是旧值。</p>
<p><strong>接口</strong>。在面向对象的程序中，不同类型的对象共享相同的属性名称是非常常见的。对象接口是一组属性和对这些属性的条件的集合。例如，所有账户必须具有接受数值参数的 <code>deposit</code> 和 <code>withdraw</code> 方法，以及一个 <code>balance</code> 属性。类 <code>Account</code> 和 <code>CheckingAccount</code> 都实现了这个接口。继承特别促进了这种方式的名称共享。在一些编程语言（如Java）中，接口实现必须显式声明。在其他语言（如Python、Ruby和Go）中，具有适当名称的任何对象都实现了一个接口。</p>
<p>例如，假设我们办了一个彩票，我们希望向一系列账户中的每个账户存入5美元。以下实现不假设这些账户的类型，因此对于任何具有 <code>deposit</code> 方法的对象类型都同样适用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">deposit_all</span>(<span class="params">winners, amount=<span class="number">5</span></span>):</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> winners:</span><br><span class="line">            account.deposit(amount)</span><br></pre></td></tr></table></figure>
<p>上述的函数 <code>deposit_all</code> 只假设每个 <code>account</code> 都满足账户对象抽象，并且它将与任何其他实现了该接口的账户类一起工作。假设特定类的账户将违反账户对象抽象的抽象屏障。例如，以下实现不一定适用于新类型的账户：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">deposit_all</span>(<span class="params">winners, amount=<span class="number">5</span></span>):</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> winners:</span><br><span class="line">            Account.deposit(account, amount)</span><br></pre></td></tr></table></figure>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>Python支持子类从多个基类继承属性的概念，这是一种称为多重继承的语言特性。</p>
<p>假设我们有一个继承自 <code>Account</code> 的 <code>SavingsAccount</code> ，但每次客户存款时都会收取一小笔费用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">SavingsAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">        deposit_charge = <span class="number">2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">return</span> Account.deposit(self, amount - self.deposit_charge)</span><br></pre></td></tr></table></figure>
<p>然后，一个聪明的高管构想出一个账户，结合了 <code>AsSeenOnTVAccount</code> 和 <code>CheckingAccount</code> 的最佳特点：取款费用、存款费用和低利率。它既是支票账户又是储蓄账户！高管推理道：“如果我们建立它，有人会注册并支付所有这些费用。我们甚至会给他们一美元。”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">AsSeenOnTVAccount</span>(CheckingAccount, SavingsAccount):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            self.balance = <span class="number">1</span>           <span class="comment"># A free dollar!</span></span><br></pre></td></tr></table></figure>
<p>实际上，这个实现是完整的。提款和存款都会产生费用，分别使用 <code>CheckingAccount</code> 和 <code>SavingsAccount</code> 中的函数定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal = AsSeenOnTVAccount(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.balance</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit(<span class="number">20</span>)            <span class="comment"># $2 fee from SavingsAccount.deposit</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw(<span class="number">5</span>)            <span class="comment"># $1 fee from CheckingAccount.withdraw</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>非歧义引用按预期正确解析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit_charge</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw_charge</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>但是当引用不明确时呢，比如对同时在 <code>Account</code> 和 <code>CheckingAccount</code> 中定义的 <code>withdraw</code> 方法的引用？下面的图表描述了 <code>AsSeenOnTVAccount</code> 类的继承图。每个箭头指向一个子类到一个基类。</p>
<p><img src="https://www.composingprograms.com/img/multiple_inheritance.png" alt="img"></p>
<p>对于像这样的简单的“菱形”形状，Python 从左到右，然后向上解析名称。在这个例子中，Python 按顺序检查以下类中的属性名称，直到找到具有该名称的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsSeenOnTVAccount, CheckingAccount, SavingsAccount, Account, <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>对于继承顺序问题，没有正确的解决方案，因为有些情况下我们可能更喜欢给某些继承的类优先权。然而，任何支持多重继承的编程语言都必须以一致的方式选择某种顺序，以便语言的用户可以预测其程序的行为。</p>
<p><strong>进一步阅读</strong>。Python 使用一种递归算法称为 C3 方法解析顺序来解析此名称。可以使用所有类上的 <code>mro</code> 方法查询任何类的方法解析顺序。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mxkgf.github.io/2024/04/06/%E5%BA%8F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="马晓康">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/06/%E5%BA%8F%E5%88%97/" class="post-title-link" itemprop="url">序列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-06 20:49:00" itemprop="dateCreated datePublished" datetime="2024-04-06T20:49:00+08:00">2024-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-04-09 12:34:27" itemprop="dateModified" datetime="2024-04-09T12:34:27+08:00">2024-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>序列是值的有序集合。该序列是计算机科学中强大的基本抽象。序列不是特定内置类型或抽象数据表示的实例，而是在几种不同类型的数据之间共享的行为的集合。也就是说，序列有很多种，但它们都有共同的行为。尤其，</p>
<p><strong>长度</strong>。序列的长度是有限的。空序列的长度为 0。</p>
<p><strong>元素选择</strong>。序列的元素对应于任何小于其长度的非负整数索引，第一个元素从 0 开始。</p>
<p>Python 包含几种本机数据类型，即序列，其中最重要的是 <code>list</code> 。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><code>list</code> 值是一个可以具有任意长度的序列。列表具有大量内置行为，以及表达这些行为的特定语法。我们已经看到了列表文字，其计算结果为 <code>list</code> 实例，以及计算结果为列表中的值的元素选择表达式。内置的 <code>len</code> 函数返回序列的长度。下面， <code>digits</code> 是一个包含四个元素的列表。索引 3 处的元素是 8。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(digits)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits[<span class="number">3</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>此外，列表可以相加并乘以整数。对于序列，加法和乘法不会将元素相加或相乘，而是组合并复制序列本身。也就是说， <code>operator</code> 模块中的 <code>add</code> 函数（以及 <code>+</code> 运算符）生成一个列表，该列表是所添加参数的串联。 <code>operator</code> 中的 <code>mul</code> 函数（以及 <code>*</code> 运算符）可以采用一个列表和一个整数 <code>k</code> 来返回包含以下内容的列表： <code>k</code> 原始列表的重复。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>, <span class="number">7</span>] + digits * <span class="number">2</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>任何值都可以包含在列表中，包括另一个列表。可以多次应用元素选择，以便在包含列表的列表中选择深度嵌套的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs = [[<span class="number">10</span>, <span class="number">20</span>], [<span class="number">30</span>, <span class="number">40</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs[<span class="number">1</span>]</span><br><span class="line">[<span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<h3 id="序列迭代"><a href="#序列迭代" class="headerlink" title="序列迭代"></a>序列迭代</h3><p>在许多情况下，我们希望迭代一个序列的元素，并对每个元素进行一些计算。这种模式非常常见，Python 提供了一种额外的控制语句来处理顺序数据：for 循环语句。</p>
<p>考虑一个问题，即计算一个值在序列中出现的次数。我们可以使用一个 for 循环来实现一个函数来计算这个次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">s, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Count the number of occurrences of value in sequence s.&quot;&quot;&quot;</span></span><br><span class="line">        total, index = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[index] == value:</span><br><span class="line">                total = total + <span class="number">1</span></span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count(digits, <span class="number">8</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Python 的 for 循环语句可以简化这个函数体，直接迭代元素值，而不需要引入任何名称。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">s, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Count the number of occurrences of value in sequence s.&quot;&quot;&quot;</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> elem == value:</span><br><span class="line">                total = total + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count(digits, <span class="number">8</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>一个 <code>for</code> 语句由一个形式为的单个从句组成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>
<p>通过以下步骤执行一个 <code>for</code> 语句：</p>
<ol>
<li>评估头部 <code>&lt;expression&gt;</code> ，它必须产生一个可迭代的值。</li>
<li>对于该可迭代值中的每个元素值，按顺序执行以下操作：<ol>
<li>将 <code>&lt;name&gt;</code> 绑定到当前帧中的该值。</li>
<li>Execute the <code>&lt;suite&gt;</code>. 执行 <code>&lt;suite&gt;</code> 。</li>
</ol>
</li>
</ol>
<p>这个评估过程的一个重要结果是，在执行 <code>&lt;name&gt;</code> 语句后， <code>&lt;name&gt;</code> 将绑定到序列的最后一个元素。循环 <code>for</code> 引入了另一种通过语句更新环境的方式。</p>
<p><strong>序列解包</strong>。程序中常见的一种模式是有一个元素序列，这些元素本身也是序列，但长度固定。一个 <code>for</code>语句可以在其头部包含多个名称，以将每个元素序列“解包”为其各自的元素。例如，我们可能有一个包含两个元素列表的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>并希望找出其中具有相同第一个和第二个元素的这些对的数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>same_count = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>以下具有两个名称的 <code>for</code> 语句将分别将每个名称 <code>x</code> 和 <code>y</code> 绑定到每对中的第一个和第二个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> pairs:</span><br><span class="line">        <span class="keyword">if</span> x == y:</span><br><span class="line">            same_count = same_count + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>same_count</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>将多个名称绑定到多个值的固定长度序列的模式称为序列解包；这与将多个名称绑定到多个值的赋值语句中看到的模式相同。</p>
<p><strong>范围</strong>。在Python中， <code>range</code> 是另一种内置的序列类型，表示一系列整数的范围。范围是使用 <code>range</code> 创建的，它接受两个整数参数：所需范围中的第一个数字和最后一个数字之后的一个数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)  <span class="comment"># Includes 1, but not 10</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>调用 <code>list</code> 构造函数的范围将评估为具有与范围相同元素的列表，以便可以轻松检查元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>, <span class="number">8</span>))</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>如果只提供一个参数，则将其解释为从0开始的范围的最后一个值之后的一个值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>范围通常出现在 <code>for</code> 头部的表达式中，用于指定套件应该执行的次数：如果在套件中未使用该名称，常见的约定是在 <code>for</code> 头部中使用一个下划线字符作为名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Go Bears!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br></pre></td></tr></table></figure>
<p>这个下划线在解释器看来只是环境中的另一个名称，但在程序员中有一个传统的含义，表示该名称不会出现在任何未来的表达式中。</p>
<h3 id="序列处理"><a href="#序列处理" class="headerlink" title="序列处理"></a>序列处理</h3><p>序列是一种常见的复合数据形式，整个程序通常围绕这个单一的抽象进行组织。具有序列作为输入和输出的模块化组件可以混合和匹配以执行数据处理。通过将一系列简单而专注的序列处理操作链接在一起，可以定义复杂的组件。</p>
<p><strong>列表推导式</strong>。许多序列处理操作可以通过对序列中的每个元素求值并将结果值收集到一个结果序列中来表达。在Python中，列表推导式是执行这种计算的表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>odds = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x+<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> odds]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>上面的 <code>for</code> 关键字不是 <code>for</code> 语句的一部分，而是列表推导式的一部分，因为它包含在方括号中。子表达式 <code>x+1</code> 会根据 <code>odds</code> 中的每个元素依次绑定到 <code>x</code> ，并将结果值收集到一个列表中。</p>
<p>另一个常见的序列处理操作是选择满足某些条件的值的子集。列表推导也可以表达这种模式，例如选择所有能够整除 <code>25</code> 的 <code>odds</code> 元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> odds <span class="keyword">if</span> <span class="number">25</span> % x == <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>列表推导式的一般形式是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;<span class="built_in">map</span> expression&gt; <span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;sequence expression&gt; <span class="keyword">if</span> &lt;<span class="built_in">filter</span> expression&gt;]</span><br></pre></td></tr></table></figure>
<p>为了评估列表推导式，Python评估 <code>&lt;sequence expression&gt;</code> ，它必须返回一个可迭代的值。然后，按顺序对每个元素进行绑定，将元素值绑定到 <code>&lt;name&gt;</code> ，评估过滤表达式，如果它返回一个真值，就评估映射表达式。映射表达式的值被收集到一个列表中。</p>
<p>聚合。在序列处理中，第三种常见模式是将序列中的所有值聚合为一个单一的值。内置函数 <code>sum</code> 、 <code>min</code>和 <code>max</code> 都是聚合函数的示例。</p>
<p>通过将对每个元素进行表达式评估的模式、选择元素的子集和聚合元素的模式结合起来，我们可以使用序列处理方法来解决问题。</p>
<p>完美数是一个正整数，它等于它的约数之和。约数是小于 <code>n</code> 的正整数，可以整除 <code>n</code> 。列举 <code>n</code> 的约数可以用列表推导式表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">divisors</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>] + [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n) <span class="keyword">if</span> n % x == <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divisors(<span class="number">4</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divisors(<span class="number">12</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>使用 <code>divisors</code> ，我们可以用另一个列表推导式计算出从 1 到 1000 的所有完美数。（通常认为 1 也是一个完美数，但它不符合我们对 <code>divisors</code> 的定义。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[n <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000</span>) <span class="keyword">if</span> <span class="built_in">sum</span>(divisors(n)) == n]</span><br><span class="line">[<span class="number">6</span>, <span class="number">28</span>, <span class="number">496</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以重复使用我们对 <code>divisors</code> 的定义来解决另一个问题，即找到一个具有整数边长的矩形的最小周长，已知其面积。矩形的面积等于其高度乘以宽度。因此，已知面积和高度，我们可以计算出宽度。我们可以断言宽度和高度都能够整除面积，以确保边长为整数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">width</span>(<span class="params">area, height</span>):</span><br><span class="line">        <span class="keyword">assert</span> area % height == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> area // height</span><br></pre></td></tr></table></figure>
<p>矩形的周长是其边长之和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">width, height</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * width + <span class="number">2</span> * height</span><br></pre></td></tr></table></figure>
<p>一个长方形的高度必须是其面积的一个因数。我们可以通过考虑所有可能的高度来计算最小的周长。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">minimum_perimeter</span>(<span class="params">area</span>):</span><br><span class="line">        heights = divisors(area)</span><br><span class="line">        perimeters = [perimeter(width(area, h), h) <span class="keyword">for</span> h <span class="keyword">in</span> heights]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(perimeters)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>area = <span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>width(area, <span class="number">5</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>perimeter(<span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>perimeter(<span class="number">10</span>, <span class="number">8</span>)</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>minimum_perimeter(area)</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[minimum_perimeter(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">12</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure>
<p><strong>高阶函数</strong>。我们在序列处理中观察到的常见模式可以使用高阶函数来表达。首先，对序列中的每个元素求值可以通过将函数应用于每个元素来表达。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">apply_to_all</span>(<span class="params">map_fn, s</span>):</span><br><span class="line">        <span class="keyword">return</span> [map_fn(x) <span class="keyword">for</span> x <span class="keyword">in</span> s]</span><br></pre></td></tr></table></figure>
<p>仅选择满足某个表达式为真的元素可以通过对每个元素应用函数来表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">keep_if</span>(<span class="params">filter_fn, s</span>):</span><br><span class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> s <span class="keyword">if</span> filter_fn(x)]</span><br></pre></td></tr></table></figure>
<p>最后，许多形式的聚合可以通过反复将一个二元函数应用于迄今为止的值和每个元素来表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">reduce</span>(<span class="params">reduce_fn, s, initial</span>):</span><br><span class="line">        reduced = initial</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            reduced = reduce_fn(reduced, x)</span><br><span class="line">        <span class="keyword">return</span> reduced</span><br></pre></td></tr></table></figure>
<p> 我们也可以使用这些高阶函数来找到完美数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">divisors_of</span>(<span class="params">n</span>):</span><br><span class="line">        divides_n = <span class="keyword">lambda</span> x: n % x == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>] + keep_if(divides_n, <span class="built_in">range</span>(<span class="number">2</span>, n))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divisors_of(<span class="number">12</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_of_divisors</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> reduce(add, divisors_of(n), <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">perfect</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> sum_of_divisors(n) == n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keep_if(perfect, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">28</span>, <span class="number">496</span>]</span><br></pre></td></tr></table></figure>
<p><strong>常规名称</strong>。在计算机科学界， <code>apply_to_all</code> 的更常见名称是 <code>map</code> ， <code>keep_if</code> 的更常见名称是 <code>filter</code> 。在Python中，内置的 <code>map</code> 和 <code>filter</code> 是这些函数的泛化版本，它们不返回列表。</p>
<p>上述定义等同于将内置的 <code>map</code> 和 <code>filter</code> 调用的结果应用于 <code>list</code> 构造函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>apply_to_all = <span class="keyword">lambda</span> map_fn, s: <span class="built_in">list</span>(<span class="built_in">map</span>(map_fn, s))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keep_if = <span class="keyword">lambda</span> filter_fn, s: <span class="built_in">list</span>(<span class="built_in">filter</span>(filter_fn, s))</span><br></pre></td></tr></table></figure>
<p><code>reduce</code> 函数是Python标准库中 <code>functools</code> 模块内置的。在这个版本中， <code>initial</code> 参数是可选的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">product</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">return</span> reduce(mul, s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>product([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure>
<p>在Python程序中，直接使用列表推导式而不是高阶函数更为常见，但两种方法都广泛用于序列处理。</p>
<h3 id="序列抽象"><a href="#序列抽象" class="headerlink" title="序列抽象"></a>序列抽象</h3><p>我们已经介绍了两种满足序列抽象的本地数据类型：列表和范围。它们都满足我们在本节开始时提出的条件：长度和元素选择。Python 还包括了两种扩展序列抽象的序列类型的行为。</p>
<p><strong>成员资格</strong>。可以测试一个值是否属于一个序列。Python有两个运算符 <code>in</code> 和 <code>not in</code> ，根据元素是否出现在序列中，它们的结果为 <code>True</code> 或 <code>False</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">in</span> digits</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1828</span> <span class="keyword">not</span> <span class="keyword">in</span> digits</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>切片</strong>。序列中包含较小的序列。序列的切片是原始序列的任何连续范围，由一对整数指定。与 <code>range</code>构造函数一样，第一个整数表示切片的起始索引，第二个整数表示结束索引之后的位置。</p>
<p>列举Python序列抽象的这些附加行为给了我们一个机会来思考什么构成了一个通用的有用数据抽象。抽象的丰富性（即包含多少行为）会产生后果。对于抽象的用户来说，附加行为可能是有帮助的。另一方面，用一个新的数据类型满足丰富抽象的要求可能是具有挑战性的。丰富抽象的另一个负面后果是用户需要更长时间来学习。</p>
<p>序列在计算中非常普遍，因此具有丰富的抽象。学习一些复杂的行为是合理的。一般来说，大多数用户定义的抽象应尽可能简单。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>文本值对于计算机科学来说可能比数字更基础。以 Python 程序为例，它们是以文本形式编写和存储的。Python 中用于表示文本的本地数据类型称为字符串，对应于构造函数 <code>str</code> 。</p>
<p>在Python中，字符串的表示、表达和操作有许多细节。字符串是丰富抽象的另一个例子，对程序员来说，掌握它需要相当大的投入。</p>
<p>字符串字面值可以表示任意文本，可以用单引号或双引号括起来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;I am string!&#x27;</span></span><br><span class="line"><span class="string">&#x27;I am string!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;I&#x27;ve got an apostrophe&quot;</span></span><br><span class="line"><span class="string">&quot;I&#x27;ve got an apostrophe&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;您好&#x27;</span></span><br><span class="line"><span class="string">&#x27;您好&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们已经在我们的代码中看到了字符串，作为文档字符串，在对 <code>print</code> 的调用中，以及作为 <code>assert</code> 语句中的错误消息。</p>
<p>字符串满足我们在本节开始时介绍的序列的两个基本条件：它们具有长度并支持元素选择。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>city = <span class="string">&#x27;Berkeley&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(city)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city[<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;k&#x27;</span></span><br></pre></td></tr></table></figure>
<p>字符串的元素本身就是只有一个字符的字符串。字符可以是字母、标点符号或其他符号。与许多其他编程语言不同，Python没有单独的字符类型；任何文本都是字符串，表示单个字符的字符串长度为1。</p>
<p>像列表一样，字符串也可以通过加法和乘法进行组合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Berkeley&#x27;</span> + <span class="string">&#x27;, CA&#x27;</span></span><br><span class="line"><span class="string">&#x27;Berkeley, CA&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Shabu &#x27;</span> * <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;Shabu Shabu &#x27;</span></span><br></pre></td></tr></table></figure>
<p>成员资格。字符串的行为与Python中的其他序列类型不同。字符串抽象不符合我们为列表和范围描述的完整序列抽象。特别是，成员运算符 <code>in</code> 适用于字符串，但其行为与应用于序列时完全不同。它匹配子字符串而不是元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;here&#x27;</span> <span class="keyword">in</span> <span class="string">&quot;Where&#x27;s Waldo?&quot;</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>多行文字。字符串不限于单行。三个引号用于界定跨越多行的字符串文字。我们已经广泛地使用了这种三重引号来编写文档字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&quot;&quot;The Zen of Python</span></span><br><span class="line"><span class="string">claims, Readability counts.</span></span><br><span class="line"><span class="string">Read more: import this.&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;The Zen of Python\nclaims, &quot;Readability counts.&quot;\nRead more: import this.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在上面的打印结果中， <code>\n</code> （发音为“反斜杠 en”）是一个表示换行的单个元素。尽管它看起来是两个字符（反斜杠和“n”），但在长度和元素选择方面，它被视为一个单一字符。</p>
<p><strong>字符串强制转换</strong>。在Python中，可以通过调用构造函数并将对象值作为参数来从任何对象创建字符串。字符串的这个特性对于从不同类型的对象构建描述性字符串非常有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">2</span>) + <span class="string">&#x27; is an element of &#x27;</span> + <span class="built_in">str</span>(digits)</span><br><span class="line"><span class="string">&#x27;2 is an element of [1, 8, 2, 8]&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>我们能够将列表用作其他列表的元素，为我们的编程语言提供了一种新的组合方式。这种能力被称为数据类型的闭包属性。一般来说，如果组合的结果可以使用相同的方法再次组合，那么组合数据值的方法具有闭包属性。闭包是任何组合方式的关键，因为它允许我们创建层次结构 - 由部分组成的结构，这些部分本身又由部分组成，依此类推。</p>
<p>在列表中嵌套列表可能会引入复杂性。树是一种基本的数据抽象，它对层次结构的值的结构和操作施加了规律性。</p>
<p>一棵树有一个根标签和一系列的分支。每个树的分支都是一棵树。没有分支的树被称为叶子。任何包含在树中的树都被称为该树的子树（例如分支的分支）。树的每个子树的根被称为该树中的节点。</p>
<p>树的数据抽象包括构造函数 <code>tree</code> 和选择器 <code>label</code> 和 <code>branches</code> 。我们从一个简化版本开始。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">root_label, branches=[]</span>):</span><br><span class="line">        <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">            <span class="keyword">assert</span> is_tree(branch), <span class="string">&#x27;branches must be trees&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> [root_label] + <span class="built_in">list</span>(branches)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span>):</span><br><span class="line">        <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">branches</span>(<span class="params">tree</span>):</span><br><span class="line">        <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<p>一棵树只有在具有根标签且所有分支也是树的情况下才是良好形态的。在 <code>tree</code> 构造函数中应用 <code>is_tree</code> 函数来验证所有分支是否良好形态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">is_tree</span>(<span class="params">tree</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(tree) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><code>is_leaf</code> 函数检查一棵树是否有分支。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">tree</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br></pre></td></tr></table></figure>
<p>树可以通过嵌套表达式构建。以下树 <code>t</code> 具有根标签3和两个分支。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = tree(<span class="number">3</span>, [tree(<span class="number">1</span>), tree(<span class="number">2</span>, [tree(<span class="number">1</span>), tree(<span class="number">1</span>)])])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">[<span class="number">3</span>, [<span class="number">1</span>], [<span class="number">2</span>, [<span class="number">1</span>], [<span class="number">1</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label(t)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>branches(t)</span><br><span class="line">[[<span class="number">1</span>], [<span class="number">2</span>, [<span class="number">1</span>], [<span class="number">1</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label(branches(t)[<span class="number">1</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_leaf(t)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_leaf(branches(t)[<span class="number">0</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mxkgf.github.io/2024/04/06/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="马晓康">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/06/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">高阶函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-04-06 18:49:00 / Modified: 20:57:15" itemprop="dateCreated datePublished" datetime="2024-04-06T18:49:00+08:00">2024-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>函数是一种抽象方法，它描述独立于其参数的特定值的复合操作。也就是说，在 <code>square</code> 中，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure>
<p>我们不是在谈论特定数字的平方，而是在谈论获得任何数字的平方的方法。为了将某些通用模式表达为命名概念，我们需要构造可以接受其他函数作为参数或返回函数作为值的函数。操纵函数的函数称为高阶函数。本节展示高阶函数如何作为强大的抽象机制，极大地增强我们语言的表达能力。</p>
<h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><p>考虑以下三个函数，它们都计算总和。第一个 <code>sum_naturals</code> 计算 <code>n</code> 之前的自然数之和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_naturals(<span class="number">100</span>)</span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure>
<p>第二个 <code>sum_cubes</code> 计算 <code>n</code> 之前的自然数的立方和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_cubes</span>(<span class="params">n</span>):</span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + k*k*k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_cubes(<span class="number">100</span>)</span><br><span class="line"><span class="number">25502500</span></span><br></pre></td></tr></table></figure>
<p>第三个 <code>pi_sum</code> 计算系列中的项之和</p>
<p><img src="https://www.composingprograms.com/img/pi_sum.png" alt="img"></p>
<p>收敛到 pi 的速度非常慢。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pi_sum</span>(<span class="params">n</span>):</span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + <span class="number">8</span> / ((<span class="number">4</span>*k-<span class="number">3</span>) * (<span class="number">4</span>*k-<span class="number">1</span>)), k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi_sum(<span class="number">100</span>)</span><br><span class="line"><span class="number">3.1365926848388144</span></span><br></pre></td></tr></table></figure>
<p>这三个功能显然具有共同的基本模式。它们大部分是相同的，仅在名称和用于计算要添加的项的 <code>k</code> 功能上有所不同。我们可以通过填充同一模板中的槽来生成每个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(n):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + &lt;term&gt;(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
<p>这种常见模式的存在有力地证明了有一个有用的抽象等待浮出水面。这些函数中的每一个都是项的总和。作为程序设计者，我们希望我们的语言足够强大，以便我们可以编写一个表达求和本身概念的函数，而不仅仅是计算特定总和的函数。我们可以在 Python 中轻松完成此操作，方法是采用上面所示的通用模板并将“槽”转换为形式参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">n, term</span>):</span><br><span class="line">	total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">		total, k = total + term(k), k + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cube</span>(<span class="params">x</span>):</span><br><span class="line">	<span class="keyword">return</span> x*x*x</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_cubes</span>(<span class="params">n</span>):</span><br><span class="line">	<span class="keyword">return</span> summation(n, cube)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>使用返回其参数的 <code>identity</code> 函数，我们还可以使用完全相同的 <code>summation</code> 函数对自然数求和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">n, term</span>):</span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + term(k), k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">identity</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> summation(n, identity)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_naturals(<span class="number">10</span>)</span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>
<p><code>summation</code> 函数也可以直接调用，无需为特定序列定义另一个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>summation(<span class="number">10</span>, square)</span><br><span class="line"><span class="number">385</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>summation</code> 抽象来定义 <code>pi_sum</code> ，方法是定义一个函数 <code>pi_term</code> 来计算每个项。我们传递参数 <code>1e6</code> （ <code>1 * 10^6 = 1000000</code> 的简写）来生成 pi 的近似值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pi_term</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span> / ((<span class="number">4</span>*x-<span class="number">3</span>) * (<span class="number">4</span>*x-<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pi_sum</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> summation(n, pi_term)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi_sum(<span class="number">1e6</span>)</span><br><span class="line"><span class="number">3.141592153589902</span></span><br></pre></td></tr></table></figure>
<h3 id="函数作为通用方法"><a href="#函数作为通用方法" class="headerlink" title="函数作为通用方法"></a>函数作为通用方法</h3><p>我们引入了用户定义函数作为抽象数值运算模式的机制，以使它们独立于所涉及的特定数字。通过高阶函数，我们开始看到一种更强大的抽象：一些函数表达通用的计算方法，独立于它们调用的特定函数。</p>
<p>尽管对函数含义进行了概念扩展，但我们如何评估调用表达式的环境模型却优雅地扩展到高阶函数的情况，而无需更改。当用户定义的函数应用于某些参数时，形式参数将在新的局部框架中绑定到这些参数的值（可能是函数）。</p>
<p>考虑以下示例，它实现了迭代改进的通用方法并使用它来计算黄金比例。黄金比例，通常称为“phi”，是一个接近 1.6 的数字，经常出现在自然、艺术和建筑中。</p>
<p>迭代改进算法从方程的解 <code>guess</code> 开始。它重复应用 <code>update</code> 函数来改进猜测，并应用 <code>close</code> 比较来检查当前 <code>guess</code> 是否“足够接近”以被认为是正确的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, close, guess=<span class="number">1</span></span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line">            guess = update(guess)</span><br><span class="line">        <span class="keyword">return</span> guess</span><br></pre></td></tr></table></figure>
<p>这个 <code>improve</code> 函数是重复求精的一般表达。它没有指定要解决的问题：这些详细信息留给作为参数传入的 <code>update</code> 和 <code>close</code> 函数。</p>
<p>黄金比例的众所周知的属性之一是，它可以通过将任何正数的倒数与 1 重复相加来计算，并且它比其平方少 1。我们可以将这些属性表示为与 <code>improve</code> 一起使用的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">golden_update</span>(<span class="params">guess</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square_close_to_successor</span>(<span class="params">guess</span>):</span><br><span class="line">        <span class="keyword">return</span> approx_eq(guess * guess, guess + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>上面，我们引入了对 <code>approx_eq</code> 的调用，如果其参数彼此近似相等，则返回 <code>True</code> 。为了实现 <code>approx_eq</code> ，我们可以将两个数字之间的差异的绝对值与一个小的容差值进行比较。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-15</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br></pre></td></tr></table></figure>
<p>使用参数 <code>golden_update</code> 和 <code>square_close_to_successor</code> 调用 <code>improve</code> 将计算黄金比例的有限近似值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>improve(golden_update, square_close_to_successor)</span><br><span class="line"><span class="number">1.6180339887498951</span></span><br></pre></td></tr></table></figure>
<p>这个例子说明了计算机科学中两个相关的重要思想。首先，命名和函数使我们能够抽象出大量的复杂性。虽然每个函数的定义都很琐碎，但我们的评估程序启动的计算过程却相当复杂。其次，只有凭借Python语言有一个极其通用的评估程序，小组件才能组合成复杂的流程。了解解释程序的过程使我们能够验证和检查我们创建的过程。</p>
<p>与往常一样，我们的新通用方法 <code>improve</code> 需要进行测试来检查其正确性。黄金比例可以提供这样的测试，因为它也有一个精确的封闭式解，我们可以将其与这个迭代结果进行比较。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phi = <span class="number">1</span>/<span class="number">2</span> + sqrt(<span class="number">5</span>)/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">improve_test</span>():</span><br><span class="line">        approx_phi = improve(golden_update, square_close_to_successor)</span><br><span class="line">        <span class="keyword">assert</span> approx_eq(phi, approx_phi), <span class="string">&#x27;phi differs from its approximation&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>improve_test()</span><br></pre></td></tr></table></figure>
<p>对于此测试，没有消息就是好消息： <code>improve_test</code> 在其 <code>assert</code> 语句成功执行后返回 <code>None</code> 。</p>
<h3 id="定义函数-III：嵌套定义"><a href="#定义函数-III：嵌套定义" class="headerlink" title="定义函数 III：嵌套定义"></a>定义函数 III：嵌套定义</h3><p>上面的示例演示了将函数作为参数传递的能力如何显着增强我们的编程语言的表达能力。每个一般概念或方程都映射到它自己的短函数上。这种方法的一个负面后果是，全局框架变得混乱，充满了小函数的名称，而这些名称都必须是唯一的。另一个问题是我们受到特定函数签名的限制： <code>improve</code> 的 <code>update</code>参数必须恰好采用一个参数。嵌套函数定义解决了这两个问题，但要求我们丰富我们的环境模型。</p>
<p>让我们考虑一个新问题：计算数字的平方根。在编程语言中，“平方根”通常缩写为 <code>sqrt</code> 。重复应用以下更新会收敛到 <code>a</code> 的平方根：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> (x + y)/<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sqrt_update</span>(<span class="params">x, a</span>):</span><br><span class="line">        <span class="keyword">return</span> average(x, a/x)</span><br></pre></td></tr></table></figure>
<p>这个双参数更新函数与 <code>improve</code> 不兼容（它需要两个参数，而不是一个），并且它只提供单个更新，而我们真正关心的是通过重复更新来求平方根。解决这两个问题的方法是将函数定义放在其他定义的主体中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sqrt</span>(<span class="params">a</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sqrt_update</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> average(x, a/x)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sqrt_close</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> approx_eq(x * x, a)</span><br><span class="line">        <span class="keyword">return</span> improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></table></figure>
<p>与本地赋值一样，本地 <code>def</code> 语句仅影响当前本地框架。这些函数仅在评估 <code>sqrt</code> 时才在范围内。与我们的评估过程一致，这些本地 <code>def</code> 语句在调用 <code>sqrt</code> 之前甚至不会被评估。</p>
<p>我们需要对环境模型进行两个扩展才能启用词法作用域。</p>
<ol>
<li>每个用户定义的函数都有一个父环境：定义它的环境。</li>
<li>当调用用户定义的函数时，其本地框架将扩展其父环境。</li>
</ol>
<p>在 <code>sqrt</code> 之前，所有函数都是在全局环境中定义的，因此它们都具有相同的父级：全局环境。相比之下，当 Python 计算 <code>sqrt</code> 的前两个子句时，它会创建与本地环境关联的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqrt(<span class="number">256</span>)</span><br><span class="line"><span class="number">16.0</span></span><br></pre></td></tr></table></figure>
<p>Python 中词法作用域的两个关键优势。</p>
<ul>
<li>局部函数的名称不会干扰定义它的函数外部的名称，因为局部函数名称将绑定在定义它的当前局部环境中，而不是全局环境中。</li>
<li>本地函数可以访问封闭函数的环境，因为本地函数的主体是在扩展了定义它的计算环境的环境中计算的。</li>
</ul>
<p><code>sqrt_update</code> 函数带有一些数据：在定义它的环境中引用的 <code>a</code> 的值。因为它们以这种方式“封装”信息，所以本地定义的函数通常称为<strong>闭包</strong>。</p>
<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>通过创建返回值本身就是函数的函数，我们可以在程序中获得更强的表达能力。词法作用域编程语言的一个重要特性是本地定义的函数在返回时保留其父环境。以下示例说明了此功能的实用性。</p>
<p>一旦定义了许多简单的函数，函数组合就是包含在我们的编程语言中的自然组合方法。也就是说，给定两个函数 <code>f(x)</code> 和 <code>g(x)</code> ，我们可能想要定义 <code>h(x) = f(g(x))</code> 。我们可以使用现有工具定义函数组合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> f(g(x))</span><br><span class="line">        <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>
<h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><p>这个扩展示例展示了函数返回值和局部定义如何协同工作以简洁地表达一般思想。我们将实现一种广泛应用于机器学习、科学计算、硬件设计和优化的算法。</p>
<p>牛顿法是一种经典的迭代方法，用于查找返回值为 0 的数学函数的参数。这些值称为函数的零点。找到函数的零通常相当于解决其他一些感兴趣的问题，例如计算平方根。在我们继续之前，有一个激励性的评论：我们很容易想当然地认为我们知道如何计算平方根。不仅是 Python，您的手机、网络浏览器或袖珍计算器也可以为您做到这一点。然而，学习计算机科学的一部分是了解如何计算这些数量，并且这里介绍的一般方法适用于求解 Python 内置方程之外的一大类方程。</p>
<p>牛顿法是一种迭代改进算法：它改进了对任何可微函数的零值的猜测，这意味着它可以在任意点用直线逼近。牛顿法遵循这些线性近似来寻找函数零点。</p>
<p>想象一条穿过点$(x,f(x))$的线，该线与该点处的函数$ f(x) $的曲线具有相同的斜率。这样的线称为切线，其斜率称为$f$在$x$处的导数。</p>
<p>这条线的斜率是函数值的变化与函数参数的变化的比率。因此，将 x 平移 f(x) 除以斜率将给出该切线接触 0 时的参数值。</p>
<p><img src="https://www.composingprograms.com/img/newton.png" alt="img"></p>
<p>对于函数$f$及其导数 $df$ ， <code>newton_update</code> 表示沿着这条切线到 0 的计算过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">newton_update</span>(<span class="params">f, df</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> x - f(x) / df(x)</span><br><span class="line">        <span class="keyword">return</span> update</span><br></pre></td></tr></table></figure>
<p>最后，我们可以根据 <code>newton_update</code> （我们的 <code>improve</code> 算法）定义 <code>find_root</code> 函数，并进行比较以查看 f(x) 是否接近0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">find_zero</span>(<span class="params">f, df</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">near_zero</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> approx_eq(f(x), <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> improve(newton_update(f, df), near_zero)</span><br></pre></td></tr></table></figure>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>我们可以使用高阶函数将带有多个参数的函数转换为每个带有单个参数的函数链。更具体地说，给定一个函数 <code>f(x, y)</code> ，我们可以定义一个函数 <code>g</code> ，使得 <code>g(x)(y)</code> 相当于 <code>f(x, y)</code> 。这里， <code>g</code> 是一个高阶函数，它接受单个参数 <code>x</code> 并返回另一个接受单个参数 <code>y</code> 的函数。这种转换称为柯里化。</p>
<p>例如，我们可以定义 <code>pow</code> 函数的柯里化版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">curried_pow</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(x, y)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>curried_pow(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>某些编程语言（例如 Haskell）只允许采用单个参数的函数，因此程序员必须柯里化所有多参数过程。在更通用的语言（例如 Python）中，当我们需要一个仅接受单个参数的函数时，柯里化非常有用。例如，映射模式将单参数函数应用于值序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">map_to_range</span>(<span class="params">start, end, f</span>):</span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            <span class="built_in">print</span>(f(start))</span><br><span class="line">            start = start + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>map_to_range</code> 和 <code>curried_pow</code> 来计算 2 的前十次方，而不是专门编写一个函数来执行此操作：</p>
<p>我们可以类似地使用相同的两个函数来计算其他数字的幂。柯里化允许我们无需为每个我们想要计算其幂的数字编写特定的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">curry2</span>(<span class="params">f</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a curried version of the given two-argument function.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">                <span class="keyword">return</span> f(x, y)</span><br><span class="line">            <span class="keyword">return</span> h</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">uncurry2</span>(<span class="params">g</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a two-argument version of the given curried function.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y</span>):</span><br><span class="line">            <span class="keyword">return</span> g(x)(y)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow_curried = curry2(<span class="built_in">pow</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow_curried(<span class="number">2</span>)(<span class="number">5</span>)</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_to_range(<span class="number">0</span>, <span class="number">10</span>, pow_curried(<span class="number">2</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">128</span></span><br><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">512</span></span><br></pre></td></tr></table></figure>
<p><code>curry2</code> 函数接受双参数函数 <code>f</code> 并返回单参数函数 <code>g</code> 。当 <code>g</code> 应用于参数 <code>x</code> 时，它返回单参数函数 <code>h</code> 。当 <code>h</code> 应用于 <code>y</code> 时，它会调用 <code>f(x, y)</code> 。因此， <code>curry2(f)(x)(y)</code> 相当于 <code>f(x, y)</code> 。 <code>uncurry2</code> 函数反转柯里化转换，因此 <code>uncurry2(curry2(f))</code> 相当于 <code>f</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uncurry2(pow_curried)(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure>
<h3 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h3><p>Python 提供了特殊的语法来应用高阶函数作为执行 <code>def</code> 语句的一部分，称为装饰器。也许最常见的例子是痕迹。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">fn</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapped</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;-&gt; &#x27;</span>, fn, <span class="string">&#x27;(&#x27;</span>, x, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> fn(x)</span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@trace</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">12</span>)</span><br><span class="line">-&gt;  &lt;function triple at <span class="number">0x102a39848</span>&gt; ( <span class="number">12</span> )</span><br><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure>
<p>在此示例中，定义了一个高阶函数 <code>trace</code> ，它返回一个函数，该函数在调用其参数之前使用输出该参数的 <code>print</code> 语句。 <code>triple</code> 的 <code>def</code> 语句有一个注释 <code>@trace</code> ，它会影响 <code>def</code> 的执行规则。像往常一样，函数 <code>triple</code> 被创建。但是，名称 <code>triple</code> 并未绑定到此函数。相反，名称 <code>triple</code> 绑定到在新定义的 <code>triple</code> 函数上调用 <code>trace</code> 的返回函数值。在代码中，这个装饰器相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = trace(triple)</span><br></pre></td></tr></table></figure>
<p>装饰器用于跟踪，以及选择当程序从命令行运行时要调用的函数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mxkgf.github.io/2024/04/05/%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="马晓康">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/05/%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" class="post-title-link" itemprop="url">控制语句</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-04-05 18:49:00 / Modified: 19:32:11" itemprop="dateCreated datePublished" datetime="2024-04-05T18:49:00+08:00">2024-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>控制语句是根据逻辑比较结果控制程序执行流程的语句。执行控制语句决定解释器接下来应该做什么，而不是计算某些内容。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>语句不是被求值，而是被执行。每个语句都描述了解释器状态的一些更改，并且执行语句会应用该更改。正如我们在 <code>return</code> 和赋值语句中看到的那样，执行语句可能涉及评估其中包含的子表达式。表达式也可以作为语句执行，在这种情况下，它们会被计算，但它们的值会被丢弃。执行纯函数没有任何效果，但执行非纯函数可能会因函数应用而产生影响。</p>
<p>例如，考虑一下，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">        mul(x, x) <span class="comment"># Watch out! This call doesn&#x27;t return a value.</span></span><br></pre></td></tr></table></figure>
<p>这个例子是有效的Python，但可能不是预期的。函数体由一个表达式组成。表达式本身是有效的语句，但该语句的效果是调用 <code>mul</code> 函数，并丢弃结果。如果您想对表达式的结果执行某些操作，则需要这样说：您可以使用赋值语句存储它，或者使用 return 语句返回它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> mul(x, x)</span><br></pre></td></tr></table></figure>
<p>有时，当调用像 <code>print</code> 这样的非纯函数时，拥有一个其主体是表达式的函数确实有意义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_square</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>(square(x))</span><br></pre></td></tr></table></figure>
<p>在最高级别上，Python 解释器的工作是执行由语句组成的程序。然而，许多有趣的计算工作都来自于表达式的求值。语句控制程序中不同表达式之间的关系以及它们的结果会发生什么。</p>
<h3 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h3><p>一般来说，Python 代码是一系列语句。简单的语句是不以冒号结尾的单行。复合语句之所以被称为复合语句，是因为它是由其他语句（简单语句和复合语句）组成的。复合语句通常跨越多行，并以一个以冒号结尾的单行标题开始，冒号标识语句的类型。标头和缩进的语句套件一起称为子句。复合语句由一个或多个子句组成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;:</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;separating header&gt;:</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    &lt;statement&gt;</span><br><span class="line">    ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们可以理解我们已经用这些术语介绍的陈述。</p>
<ul>
<li>表达式、返回语句和赋值语句是简单语句。</li>
<li><code>def</code> 语句是复合语句。 <code>def</code> 标头后面的套件定义了函数体。</li>
</ul>
<p>每种标头的专门评估规则规定了何时以及是否执行其套件中的语句。我们说标头控制其套件。例如，在 <code>def</code> 语句的情况下，我们看到返回表达式不会立即计算，而是存储起来以供最终调用定义的函数时使用。要执行一系列语句，请执行第一个语句。如果该语句没有重定向控制，则继续执行语句序列的其余部分（如果还有剩余）。</p>
<p>这个定义揭示了递归定义序列的基本结构：序列可以分解为其第一个元素和其余元素。语句序列的“其余部分”本身就是语句序列！因此，我们可以递归地应用这个执行规则。</p>
<p>此规则的重要结果是语句按顺序执行，但由于重定向控制，后面的语句可能永远不会到达。</p>
<blockquote>
<p>实用指导。缩进套件时，所有行必须以相同的方式缩进相同的量（使用空格，而不是制表符）。缩进的任何变化都会导致错误。</p>
</blockquote>
<h3 id="定义函数-II：局部赋值"><a href="#定义函数-II：局部赋值" class="headerlink" title="定义函数 II：局部赋值"></a>定义函数 II：局部赋值</h3><p>最初，我们声明用户定义函数的主体仅包含带有单个返回表达式的 <code>return</code> 语句。事实上，函数可以定义超出单个表达式的操作序列。</p>
<p>每当应用用户定义的函数时，其定义套件中的子句序列都会在本地环境中执行 - 该环境以通过调用该函数创建的本地框架开始。 <code>return</code> 语句重定向控制：每当执行第一个 <code>return</code> 语句时，函数应用程序就会终止， <code>return</code> 表达式的值是正在应用的功能。</p>
<p>函数只能操纵其本地环境这一事实对于创建模块化程序至关重要，在模块化程序中，纯函数仅通过它们获取和返回的值进行交互。</p>
<p>局部赋值并没有增加函数定义的表达能力。局部赋值还通过为中间量指定名称，在阐明复杂表达式的含义方面发挥着关键作用。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>Python 有一个用于计算绝对值的内置函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>x</code> 为正，则 <code>abs(x)</code> 返回 <code>x</code> 。此外，如果 <code>x</code> 为 0，则 <code>abs(x)</code> 返回 0。否则， <code>abs(x)</code>返回 <code>-x</code> 。在Python中，我们可以用条件语句来表达这个选择。</p>
<p><strong>条件语句</strong>。 Python 中的条件语句由一系列标头和套件组成：必需的 <code>if</code> 子句、可选的 <code>elif</code> 子句序列，最后是可选的 <code>else</code> 子句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>
<p>执行条件语句时，将按顺序考虑每个子句。执行条件子句的计算过程如下。</p>
<ol>
<li>评估标题的表达式。</li>
<li>如果它是真值，则执行该套件。然后，跳过条件语句中的所有后续子句。</li>
</ol>
<p>如果到达 <code>else</code> 子句（仅当所有 <code>if</code> 和 <code>elif</code> 表达式计算结果为假值时才会发生），则执行其套件。</p>
<p><strong>布尔上下文</strong>。上面，执行过程提到了“假值”和“真值”。条件块的头语句内的表达式被认为是在布尔上下文中：它们的真值对于控制流很重要，但否则它们的值不会被分配或返回。 Python 包含多个错误值，包括 0、 <code>None</code> 和布尔值 <code>False</code> 。所有其他数字均为真值。</p>
<p><strong>布尔值</strong>。 Python 有两个布尔值，称为 <code>True</code> 和 <code>False</code> 。布尔值表示逻辑表达式中的真值。内置比较操作 <code>&gt;, &lt;, &gt;=, &lt;=, ==, !=</code> 返回这些值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> &lt; <span class="number">2</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt;= <span class="number">5</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>第二个示例显示“5 大于或等于 5”，对应于 <code>operator</code> 模块中的函数 <code>ge</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> == -<span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>最后一个示例显示“0 等于 -0”，对应于 <code>operator</code> 模块中的 <code>eq</code> 。请注意，Python 将赋值 ( <code>=</code> ) 与相等比较 ( <code>==</code> ) 区分开来，这是许多编程语言共享的约定。</p>
<p>布尔运算符。 Python 中还内置了三个基本逻辑运算符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>逻辑表达式有相应的求值过程。这些过程利用了这样一个事实：有时可以在不评估其所有子表达式的情况下确定逻辑表达式的真值，这一特性称为短路。</p>
<p>要计算表达式 <code>&lt;left&gt; and &lt;right&gt;</code> ：</p>
<ol>
<li>计算子表达式 <code>&lt;left&gt;</code> 。</li>
<li>如果结果是假值 <code>v</code> ，则表达式的计算结果为 <code>v</code> 。</li>
<li>否则，表达式的计算结果为子表达式 <code>&lt;right&gt;</code> 的值。</li>
</ol>
<p>要计算表达式 <code>&lt;left&gt; or &lt;right&gt;</code> ：</p>
<ol>
<li>计算子表达式 <code>&lt;left&gt;</code> 。</li>
<li>如果结果是真值 <code>v</code> ，则表达式的计算结果为 <code>v</code> 。</li>
<li>否则，表达式的计算结果为子表达式 <code>&lt;right&gt;</code> 的值。</li>
</ol>
<p>要计算表达式 <code>not &lt;exp&gt;</code> ：</p>
<ol>
<li>评估 <code>&lt;exp&gt;</code> ；如果结果为假值，则值为 <code>True</code> ，否则为 <code>False</code> 。</li>
</ol>
<p>这些值、规则和运算符为我们提供了一种组合比较结果的方法。执行比较并返回布尔值的函数通常以 <code>is</code> 开头，后面不跟下划线（例如 <code>isfinite</code> 、 <code>isdigit</code> 、 <code>isinstance</code> ， ETC。）。</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>除了选择要执行的语句之外，控制语句还用于表达重复。如果我们编写的每一行代码只执行一次，那么编程将是一项非常低效的工作。只有通过重复执行语句，我们才能释放计算机的全部潜力。我们已经看到了一种形式的重复：一个函数可以被应用多次，尽管它只定义了一次。迭代控制结构是多次执行相同语句的另一种机制。</p>
<p>考虑斐波那契数列，其中每个数字都是前两个数字的总和：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21, ...</span><br></pre></td></tr></table></figure>
<p>每个值都是通过重复应用前两个求和规则来构造的。第一个和第二个固定为0和1。例如，第八个斐波那契数是13。</p>
<p><code>while</code> 子句包含一个标头表达式，后跟一个套件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>
<p>要执行 <code>while</code> 子句：</p>
<ol>
<li>评估标题的表达式。</li>
<li>如果是真值，则执行套件，然后返回步骤 1。</li>
</ol>
<p>在步骤 2 中，在再次计算标头表达式之前执行整个 <code>while</code> 子句套件。</p>
<p>为了防止 <code>while</code> 子句的套件无限期地执行，该套件应始终在每次传递中更改一些绑定。</p>
<p>不终止的 <code>while</code> 语句称为无限循环。按 <code>&lt;Control&gt;-C</code> 强制 Python 停止循环。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试函数是验证函数的行为是否符合预期的行为。我们的函数语言现在足够复杂，我们需要开始测试我们的实现。</p>
<p>测试是系统地执行此验证的一种机制。测试通常采用另一个函数的形式，其中包含对正在测试的函数的一个或多个示例调用。然后根据预期结果验证返回的值。与大多数通用函数不同，测试涉及选择和验证具有特定参数值的调用。测试也可用作文档：它们演示如何调用函数以及哪些参数值是合适的。</p>
<p><strong>Assertions(断言).</strong> 程序员使用 <code>assert</code> 语句来验证期望，例如正在测试的函数的输出。 <code>assert</code> 语句在布尔上下文中包含一个表达式，后跟带引号的文本行（单引号或双引号都可以，但要一致），如果表达式计算结果为假值，则将显示该文本行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> fib(<span class="number">8</span>) == <span class="number">13</span>, <span class="string">&#x27;The 8th Fibonacci number should be 13&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当被断言的表达式的计算结果为真值时，执行断言语句不起作用。当它为假值时， <code>assert</code> 会导致错误并停止执行。</p>
<p><code>fib</code> 的测试函数应该测试多个参数，包括 <code>n</code> 的极值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib_test</span>():</span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">2</span>) == <span class="number">1</span>, <span class="string">&#x27;The 2nd Fibonacci number should be 1&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">3</span>) == <span class="number">1</span>, <span class="string">&#x27;The 3rd Fibonacci number should be 1&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> fib(<span class="number">50</span>) == <span class="number">7778742049</span>, <span class="string">&#x27;Error at the 50th Fibonacci number&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在文件中而不是直接在解释器中编写 Python 时，测试通常编写在同一文件或后缀为 <code>_test.py</code> 的相邻文件中。</p>
<p><strong>Doctests文档测试.</strong>  Python 提供了一种方便的方法，可以将简单的测试直接放置在函数的文档字符串中。文档字符串的第一行应包含函数的单行描述，后跟一个空行。随后可能会详细描述参数和行为。此外，文档字符串可能包括调用该函数的示例交互式会话：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the sum of the first n natural numbers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(10)</span></span><br><span class="line"><span class="string">        55</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; sum_naturals(100)</span></span><br><span class="line"><span class="string">        5050</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total + k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
<p>然后，可以通过 doctest 模块验证交互。下面， <code>globals</code> 函数返回全局环境的表示，解释器需要它来计算表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> testmod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testmod()</span><br><span class="line">TestResults(failed=<span class="number">0</span>, attempted=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>为了仅验证单个函数的 doctest 交互，我们使用名为 <code>run_docstring_examples</code> 的 <code>doctest</code> 函数。 （不幸的是）这个函数的调用有点复杂。它的第一个参数是要测试的函数。第二个应该始终是表达式 <code>globals()</code> 的结果，这是一个返回全局环境的内置函数。第三个参数是 <code>True</code> 表示我们想要“详细”输出：所有运行的测试的目录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> doctest <span class="keyword">import</span> run_docstring_examples</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_docstring_examples(sum_naturals, <span class="built_in">globals</span>(), <span class="literal">True</span>)</span><br><span class="line">Finding tests <span class="keyword">in</span> NoName</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(<span class="number">10</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">55</span></span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    sum_naturals(<span class="number">100</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">5050</span></span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>当函数的返回值与预期结果不匹配时， <code>run_docstring_examples</code> 函数会将此问题报告为测试失败。</p>
<p>在文件中编写 Python 时，可以通过使用 doctest 命令行选项启动 Python 来运行文件中的所有 doctest：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m doctest &lt;python_source_file&gt;</span><br></pre></td></tr></table></figure>
<p>有效测试的关键是在实现新功能后立即编写（并运行）测试。在实现之前编写一些测试甚至是一个很好的做法，以便在您的脑海中记住一些示例输入和输出。应用单个功能的测试称为单元测试。详尽的单元测试是良好程序设计的标志。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mxkgf.github.io/2024/04/04/%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="马晓康">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/04/%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">设计函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-04-04 18:49:00 / Modified: 20:27:12" itemprop="dateCreated datePublished" datetime="2024-04-04T18:49:00+08:00">2024-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="设计函数"><a href="#设计函数" class="headerlink" title="设计函数"></a>设计函数</h2><p>函数是所有程序（无论大小）的基本组成部分，并且是我们在编程语言中表达计算过程的主要媒介。从根本上说，好函数的特质都强化了函数是抽象的概念。</p>
<ul>
<li>每个函数都应该只有一个任务。该任务应该用一个简短的名称来识别，并可以在一行文本中描述。按顺序执行多个任务的函数应划分为多个函数。</li>
<li>不要重复自己是软件工程的核心原则。所谓的 DRY 原则指出，多个代码片段不应描述冗余逻辑。相反，该逻辑应该实现一次，给定一个名称，并多次应用。如果你发现自己在复制和粘贴一个代码块，你可能已经找到了函数抽象的机会。</li>
<li>函数应笼统定义。平方不在 Python 库中，正是因为它是 <code>pow</code> 函数的一个特例，它将数字提高到任意幂。</li>
</ul>
<p>这些准则提高了代码的可读性，减少了错误数，并且通常最大限度地减少了编写的代码总量。将复杂的任务分解为简洁的函数是一项需要经验才能掌握的技能。幸运的是，Python 提供了一些功能来支持您的工作。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>函数定义通常包括描述函数的文档，称为文档字符串，该文档字符串必须与函数主体一起缩进。文档字符串通常采用三重引号。第一行用一行描述了函数的工作。以下行可以描述参数并阐明函数的行为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Compute the pressure in pascals of an ideal gas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        v -- volume of gas, in cubic meters</span></span><br><span class="line"><span class="string">        t -- absolute temperature in degrees kelvin</span></span><br><span class="line"><span class="string">        n -- particles of gas</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        k = <span class="number">1.38e-23</span>  <span class="comment"># Boltzmann&#x27;s constant</span></span><br><span class="line">        <span class="keyword">return</span> n * k * t / v</span><br></pre></td></tr></table></figure>
<p>当您使用函数的名称作为参数进行调用 <code>help</code> 时，您会看到其文档字符串（键入 <code>q</code> 以退出 Python 帮助）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(pressure)</span><br></pre></td></tr></table></figure>
<p>编写 Python 程序时，请包含除最简单函数之外的所有函数的文档字符串。请记住，代码只编写一次，但通常会读取多次。Python 文档包括文档字符串指南，用于在不同 Python 项目之间保持一致性。</p>
<p>评论。Python 中的注释可以附加到 <code>#</code> 符号后面的一行的末尾。例如，上面的评论 <code>Boltzmann&#39;s constant</code> 描述了 <code>k</code> .这些注释永远不会出现在 Python 的 <code>help</code> 中，并且它们会被解释器忽略。它们只为人类而存在。</p>
<h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>定义一般函数的一个后果是引入了额外的参数。带有许多参数的函数可能很难调用，也很难阅读。</p>
<p>在 Python 中，我们可以为函数的参数提供默认值。调用该函数时，具有默认值的参数是可选的。如果未提供它们，则默认值将绑定到正式参数名称。例如，如果应用程序通常计算一摩尔粒子的压力，则可以提供此值作为默认值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n=<span class="number">6.022e23</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Compute the pressure in pascals of an ideal gas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        v -- volume of gas, in cubic meters</span></span><br><span class="line"><span class="string">        t -- absolute temperature in degrees kelvin</span></span><br><span class="line"><span class="string">        n -- particles of gas (default: one mole)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        k = <span class="number">1.38e-23</span>  <span class="comment"># Boltzmann&#x27;s constant</span></span><br><span class="line">        <span class="keyword">return</span> n * k * t / v</span><br></pre></td></tr></table></figure>
<p>在此示例中，该 <code>=</code> 符号表示两种不同的东西，具体取决于使用它的上下文。在 <code>def</code> 语句标头中， <code>=</code> 不执行赋值，而是指示调用 <code>pressure</code> 函数时要使用的默认值。相反，函数主体 <code>k</code> 中的赋值语句将名称 <code>k</code>绑定到玻尔兹曼常数的近似值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">273.15</span>)</span><br><span class="line"><span class="number">2269.974834</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pressure(<span class="number">1</span>, <span class="number">273.15</span>, <span class="number">3</span> * <span class="number">6.022e23</span>)</span><br><span class="line"><span class="number">6809.924502</span></span><br></pre></td></tr></table></figure>
<p>该 <code>pressure</code> 函数被定义为接受三个参数，但在上面的第一个调用表达式中只提供了两个参数。在本例中， <code>n</code> 的值取自 <code>def</code> 语句 default。如果提供了第三个参数，则忽略默认值。</p>
<p>作为准则，函数正文中使用的大多数数据值都应表示为命名参数的默认值，以便易于检查并可由函数调用方更改。一些永不改变的值，例如基本常量 <code>k</code> ，可以绑定在函数体或全局框架中。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mxkgf.github.io/2024/04/03/%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="马晓康">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/03/%E5%AE%9A%E4%B9%89%E6%96%B0%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">定义新函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-04-03 18:49:00 / Modified: 19:07:03" itemprop="dateCreated datePublished" datetime="2024-04-03T18:49:00+08:00">2024-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="定义新函数"><a href="#定义新函数" class="headerlink" title="定义新函数"></a>定义新函数</h2><p><strong>如何定义一个函数</strong>。函数定义包括一个表示<name>的def语句和命名<formal parameters>的逗号分隔列表，然后是一个返回语句，称为函数主体，它指定了函数的<return expression>，这是一个在应用函数时要计算的表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(&lt;formal parameters&gt;):</span><br><span class="line">    <span class="keyword">return</span> &lt;<span class="keyword">return</span> expression&gt;</span><br></pre></td></tr></table></figure>
<p>第二行必须缩进 — 大多数程序员使用四个空格来缩进。不会立即计算返回表达式;它存储为新定义的函数的一部分，并且仅在最终应用该函数时进行计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> mul(x, x)</span><br></pre></td></tr></table></figure>
<p>定义 <code>square</code> 后，我们可以用调用表达式来应用它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">21</span>)</span><br><span class="line"><span class="number">441</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(add(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(square(<span class="number">3</span>))</span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>
<p>我们也可以用作 <code>square</code> 定义其他函数的构建块。例如，我们可以很容易地定义一个函数<code>sum_squares</code>，该函数给定任意两个数字作为参数，返回它们的平方和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">sum_squares</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> add(square(x), square(y))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_squares(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>用户定义函数的使用方式与内置函数完全相同。事实上，从sum_squares的定义中无法判断 <code>square</code> 是内置在解释器中、从模块导入还是由用户定义的。</p>
<p><code>def</code>语句和赋值语句都将名称绑定到值，并且任何现有绑定都将丢失。例如，下面的g首先是指没有参数的函数，然后是一个数字，然后是两个参数的不同函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">h, i</span>):</span><br><span class="line">        <span class="keyword">return</span> h + i</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="局部名称"><a href="#局部名称" class="headerlink" title="局部名称"></a>局部名称</h3><p>函数实现中不应影响函数行为的一个细节是实现者为函数的形式参数选择的名称。因此，以下函数应提供相同的行为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> mul(x, x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> mul(y, y)</span><br></pre></td></tr></table></figure>
<p>这一原则——函数的含义应独立于其作者选择的参数名称——对编程语言具有重要影响。最简单的结果是，函数的参数名称必须保持函数主体的局部位置。</p>
<p>如果参数不是其各自函数的主体的局部参数，则 <code>x</code> 中的 <code>square</code> 参数可能会与 <code>x</code> 中的 <code>sum_squares</code> 参数混淆。至关重要的是，情况并非如此：不同局部帧 <code>x</code> 中的绑定是无关的。计算模型经过精心设计，以确保这种独立性。</p>
<p>我们说局部名称的范围仅限于定义它的用户定义函数的主体。当某个名称无法再访问时，它就超出了范围。这种范围界定行为并不是我们模型的新事实;这是环境工作方式的结果。</p>
<h3 id="选择名称"><a href="#选择名称" class="headerlink" title="选择名称"></a>选择名称</h3><p>名称的可互换性并不意味着正式的参数名称根本不重要。相反，精心选择的函数和参数名称对于函数定义的人类可解释性至关重要！</p>
<p>以下指南改编自 Python 代码的风格指南，该指南可作为所有（非叛逆的）Python 程序员的指南。一组共享的约定使开发人员社区成员之间的通信顺畅。作为遵循这些约定的副作用，您会发现您的代码变得更加内部一致。</p>
<ol>
<li>函数名称为小写，单词之间用下划线分隔。鼓励使用描述性名称。</li>
<li>函数名通常唤起由解释器应用于参数的操作（例如，print，add，square）或结果数量的名称（例如，max，abs，sum）。</li>
<li>参数名称为小写，单词之间用下划线分隔。最好使用单字名称。</li>
<li>参数名称应唤起参数在函数中的作用，而不仅仅是允许的参数类型。</li>
<li>当单字母参数名称的作用很明显时，它们是可以接受的，但要避免使用“l”（小写 L）、“O”（大写字母 o）或“I”（大写字母 i），以避免与数字混淆。</li>
</ol>
<p>这些准则有许多例外，即使在 Python 标准库中也是如此。就像英语的词汇一样，Python 继承了各种贡献者的单词，结果并不总是一致的。</p>
<h3 id="作为抽象的函数"><a href="#作为抽象的函数" class="headerlink" title="作为抽象的函数"></a>作为抽象的函数</h3><p>虽然它非常简单，但sum_squares体现了用户定义函数最强大的属性。函数sum_squares是根据函数square定义的，但只依赖于square在其输入参数和输出值之间定义的关系。</p>
<p>我们可以写作 <code>sum_squares</code> 而不用担心如何平方一个数字。可以抑制如何计算平方的细节，稍后再考虑。事实上，就 <code>sum_squares</code> 其而言， <code>square</code> 它不是一个特定的函数体，而是函数的抽象，即所谓的函数抽象。在这个抽象级别上，任何计算平方的函数都同样好。</p>
<p>因此，仅考虑它们返回的值，以下两个用于对数字进行平方的函数应该是无法区分的。每个都接受一个数字参数，并生成该数字的平方作为值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> mul(x, x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> mul(x, x-<span class="number">1</span>) + x</span><br></pre></td></tr></table></figure>
<p>换句话说，函数定义应该能够抑制细节。该函数的用户可能不是自己编写的函数，而是作为“黑匣子”从另一个程序员那里获得的。程序员不需要知道函数是如何实现的就可以使用它。Python 库具有此属性。许多开发人员使用那里定义的函数，但很少有人检查它们的实现。</p>
<p><strong>函数抽象的各个方面</strong>。为了掌握函数抽象的使用，考虑它的三个核心属性通常是有用的。函数的域是它可以采用的参数集。函数的范围是它可以返回的值集。函数的意图是它计算输入和输出之间的关系（以及它可能产生的任何副作用）。通过函数抽象的域、范围和意图来理解函数抽象对于在复杂程序中正确使用它们至关重要。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mxkgf.github.io/2024/04/03/%E7%BC%96%E7%A8%8B%E8%A6%81%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="马晓康">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/03/%E7%BC%96%E7%A8%8B%E8%A6%81%E7%B4%A0/" class="post-title-link" itemprop="url">编程要素</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-04-03 13:49:00 / Modified: 18:00:48" itemprop="dateCreated datePublished" datetime="2024-04-03T13:49:00+08:00">2024-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="编程要素"><a href="#编程要素" class="headerlink" title="编程要素"></a>编程要素</h2><blockquote>
<p>当我们描述一种语言时，我们应该特别注意语言提供的将简单思想组合成更复杂思想的方法。每种强大的语言都有三种这样的机制：</p>
<ul>
<li><strong>原始表达式和语句</strong>，它们表示语言提供的最简单的构建块，</li>
<li><strong>组合方式</strong>，通过这种组合方式，组合元素由更简单的元素构建而成，以及</li>
<li><strong>抽象手段</strong>，通过这种手段可以将复合元素作为单元进行命名和操作。</li>
</ul>
<p>在编程中，我们处理两种元素：<strong>函数和数据</strong>。（很快我们就会发现它们真的没有那么明显。非正式地，数据是我们想要操作的东西，函数描述了操作数据的规则。）因此，任何强大的编程语言都应该能够描述原始数据和原始函数，并具有一些组合和抽象函数和数据的方法。</p>
</blockquote>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>我们从原始表达式开始。一种原始表达式是数字。更准确地说，您键入的表达式由表示以 10 为基数的数字的数字组成的数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">42</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>表示数字的表达式可以与数学运算符组合以形成复合表达式，解释器将计算该表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">1</span> - -<span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">2</span> + <span class="number">1</span>/<span class="number">4</span> + <span class="number">1</span>/<span class="number">8</span> + <span class="number">1</span>/<span class="number">16</span> + <span class="number">1</span>/<span class="number">32</span> + <span class="number">1</span>/<span class="number">64</span> + <span class="number">1</span>/<span class="number">128</span></span><br><span class="line"><span class="number">0.9921875</span></span><br></pre></td></tr></table></figure>
<h3 id="调用表达式"><a href="#调用表达式" class="headerlink" title="调用表达式"></a>调用表达式</h3><p>最重要的复合表达式是调用表达式，它将函数应用于某些参数。回想一下代数，函数的数学概念是从一些输入参数到输出值的映射。例如，该 <code>max</code> 函数将其输入映射到单个输出，该输出是最大的输入。Python 表达函数应用的方式与传统数学相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="number">7.5</span>, <span class="number">9.5</span>)</span><br><span class="line"><span class="number">9.5</span></span><br></pre></td></tr></table></figure>
<p>此调用表达式具有子表达式：运算符是括号前面的表达式，括号括起逗号分隔的操作数表达式列表。</p>
<p><img src="https://www.composingprograms.com/img/call_expression.png" alt="img"></p>
<p>运算符指定一个函数。当计算此调用表达式时，我们说使用参数 7.5 和 9.5 调用该函数 <code>max</code> ，并返回值 9.5。</p>
<p>调用表达式中参数的顺序很重要。例如，该函数 <code>pow</code> 将其第一个参数提升到第二个参数的幂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"><span class="number">1267650600228229401496703205376</span></span><br></pre></td></tr></table></figure>
<p>与中缀表示法的数学约定相比，函数表示法有三个主要优点。首先，函数可以采用任意数量的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>不会出现歧义，因为函数名称总是在其参数之前。</p>
<p>其次，函数表示法以一种直接的方式扩展到嵌套表达式，其中元素本身就是复合表达式。在嵌套调用表达式中，与复合中缀表达式不同，嵌套的结构在括号中是完全显式的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="built_in">min</span>(<span class="number">1</span>, -<span class="number">2</span>), <span class="built_in">min</span>(<span class="built_in">pow</span>(<span class="number">3</span>, <span class="number">5</span>), -<span class="number">4</span>))</span><br><span class="line">-<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这种嵌套的深度和 Python 解释器可以评估的表达式的整体复杂性（原则上）没有限制。然而，人类很快就会被多层次嵌套所迷惑。作为程序员，您的一个重要角色是构建表达式，以便您自己、您的编程伙伴以及将来可能阅读您的表达式的其他人都能解释它们。</p>
<p>第三，数学符号的形式多种多样：乘法出现在项之间，指数显示为上标，除法显示为横条，平方根显示为带有倾斜壁板的屋顶。其中一些符号很难输入！但是，所有这些复杂性都可以通过调用表达式的表示法来统一。虽然 Python 支持使用中缀符号（如 <code>+</code> 和 <code>-</code> ）的常见数学运算符，但任何运算符都可以表示为带有名称的函数。</p>
<h3 id="导入库函数"><a href="#导入库函数" class="headerlink" title="导入库函数"></a>导入库函数</h3><p>Python 定义了非常多的函数，包括运算符函数，但默认情况下不会使它们的所有名称都可用。相反，它将它所知道的函数和其他量组织到模块中，这些模块共同构成了 Python 库。要使用这些元素，请导入它们。例如，该 <code>math</code> 模块提供了各种熟悉的数学函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqrt(<span class="number">256</span>)</span><br><span class="line"><span class="number">16.0</span></span><br></pre></td></tr></table></figure>
<p>该 <code>operator</code> 模块提供对与中缀运算符对应的函数的访问：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add, sub, mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">14</span>, <span class="number">28</span>)</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub(<span class="number">100</span>, mul(<span class="number">7</span>, add(<span class="number">8</span>, <span class="number">4</span>)))</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><code>import</code> 语句指定模块名称（例如， <code>operator</code> 或 <code>math</code> ），然后列出要导入的该模块的命名属性（例如， <code>sqrt</code> ）。导入函数后，可以多次调用该函数。使用这些运算符函数（例如 <code>add</code> ）和运算符符号本身（例如 <code>+</code> ）之间没有区别。传统上，大多数程序员使用符号和中缀符号来表达简单的算术。</p>
<h3 id="名称与环境"><a href="#名称与环境" class="headerlink" title="名称与环境"></a>名称与环境</h3><p>编程语言的一个关键方面是它提供了使用名称来引用计算对象的方法。如果一个值被赋予了名称，我们说该名称绑定到该值。</p>
<p>在 Python 中，我们可以使用 assignment 语句建立新的绑定，该语句的左边有一个名称 <code>=</code>，右边有一个值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>radius = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>radius</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> * radius</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>名称也通过 <code>import</code> 语句绑定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pi * <span class="number">71</span> / <span class="number">223</span></span><br><span class="line"><span class="number">1.0002380197528042</span></span><br></pre></td></tr></table></figure>
<p>该 <code>=</code> 符号在 Python（和许多其他语言）中称为赋值运算符。赋值是我们最简单的抽象方法，因为它允许我们使用简单的名称来引用复合运算的结果，例如上面 <code>area</code> 计算的结果。通过这种方式，通过逐步构建复杂性不断增加的计算对象来构建复杂的程序。将名称绑定到值并在以后按名称检索这些值的可能性意味着解释器必须维护某种内存来跟踪名称、值和绑定。此内存称为环境。</p>
<p>名称也可以绑定到函数。例如，名称 <code>max</code> 绑定到我们一直在使用的 max 函数。与数字不同，函数很难呈现为文本，因此当要求描述函数时，Python 会打印标识描述：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">max</span>&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以使用赋值语句为现有函数提供新名称。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">max</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">max</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>连续赋值语句可以将名称重新绑定到新值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>在 Python 中，名称通常被称为变量名称或变量，因为它们可以在执行程序的过程中绑定到不同的值。当名称通过赋值绑定到新值时，它不再绑定到任何以前的值。甚至可以将内置名称绑定到新值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span> = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>赋 <code>max</code> 值为 5 后，该名称 <code>max</code> 不再绑定到函数，因此尝试调用 <code>max(2, 3, 4)</code> 将导致错误。</p>
<p>在执行赋值语句时，Python 会先计算右侧 <code>=</code> 的表达式，然后再将绑定更改为左侧的名称。因此，可以在右侧表达式中引用名称，即使它是要受赋值语句约束的名称。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = x + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>我们还可以在单个语句中为多个名称分配多个值，其中左侧的名称 <code>=</code> 和右侧 <code>=</code> 的表达式用逗号分隔。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>area, circumference = pi * radius * radius, <span class="number">2</span> * pi * radius</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>area</span><br><span class="line"><span class="number">314.1592653589793</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>circumference</span><br><span class="line"><span class="number">62.83185307179586</span></span><br></pre></td></tr></table></figure>
<p>更改一个名称的值不会影响其他名称。下面，即使名称 <code>area</code> 绑定到最初根据 定义的 <code>radius</code> 值，值 <code>area</code> 也没有改变。更新值 需要 <code>area</code> 另一个赋值语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>radius = <span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>area</span><br><span class="line"><span class="number">314.1592653589793</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>area = pi * radius * radius</span><br><span class="line"><span class="number">380.132711084365</span></span><br></pre></td></tr></table></figure>
<p>使用多个赋值时，在将左侧的任何名称绑定到这些值之前，将计算右侧 <code>=</code> 的所有表达式。由于此规则，可以在单个语句中交换绑定到两个名称的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="number">3</span>, <span class="number">4.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y, x = x, y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">4.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="计算嵌套表达式"><a href="#计算嵌套表达式" class="headerlink" title="计算嵌套表达式"></a>计算嵌套表达式</h3><p>在计算嵌套调用表达式时，解释器本身遵循一个过程。</p>
<p>为了评估调用表达式，Python 将执行以下操作：</p>
<ol>
<li>计算运算符和操作数子表达式，然后</li>
<li>将作为运算符子表达式的值的函数应用于作为操作数子表达式的值的参数。</li>
</ol>
<p>为了完成调用表达式的计算过程，我们必须首先计算其他表达式。因此，评估过程本质上是递归的;也就是说，作为其步骤之一，它包括调用规则本身的需要。例如，评估</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub(<span class="built_in">pow</span>(<span class="number">2</span>, add(<span class="number">1</span>, <span class="number">10</span>)), <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">2016</span></span><br></pre></td></tr></table></figure>
<p>要求应用此评估程序四次。如果我们绘制我们计算的每个表达式，我们可以可视化此过程的层次结构。</p>
<p><img src="https://www.composingprograms.com/img/expression_tree.png" alt="img"></p>
<p>此图称为表达式树。在计算机科学中，树木通常自上而下生长。树中每个点的对象称为节点;在本例中，它们是与其值配对的表达式。</p>
<p>评估其根，即顶部的完整表达式，需要首先评估作为其子表达式的分支。叶表达式（即没有分支的节点）表示函数或数字。内部节点由两部分组成：应用计算规则的调用表达式和该表达式的结果。从这棵树的角度来看，我们可以想象操作数的值向上渗透，从终端节点开始，然后在越来越高的级别上组合。</p>
<p>接下来，观察第一步的重复应用将我们带到了需要计算的地步，不是调用表达式，而是原始表达式，例如数字（例如，2）和名称（例如， <code>add</code> ）。我们通过规定以下方式来处理原始情况</p>
<ul>
<li>数字的计算结果为它命名的数字，</li>
<li>名称的计算结果为当前环境中与该名称关联的值。</li>
</ul>
<p>请注意环境在确定表达式中符号含义方面的重要作用。在 Python 中，谈论诸如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(x, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>而不指定任何有关环境的信息，这些信息将为名称 <code>x</code> （甚至名称 <code>add</code> ）提供含义。环境提供了进行评估的背景，这在我们理解项目执行方面起着重要作用。</p>
<p>此评估过程不足以评估所有 Python 代码，仅计算调用表达式、数字和名称。例如，它不处理赋值语句。执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>不返回值，也不计算某些参数的函数，因为赋值的目的是将名称绑定到值。通常，语句不是计算的，而是执行的;它们不会产生价值，而是做出一些改变。每种类型的表达式或语句都有自己的计算或执行过程。</p>
<blockquote>
<p>迂腐的注释：当我们说“一个数字的计算结果为一个数字”时，我们实际上是指 Python 解释器将一个数字计算为一个数字。解释器赋予编程语言以意义。鉴于解释器是一个始终一致行为的固定程序，我们可以说数字（和表达式）本身的计算结果为 Python 程序上下文中的值。</p>
</blockquote>
<h3 id="非纯打印函数"><a href="#非纯打印函数" class="headerlink" title="非纯打印函数"></a>非纯打印函数</h3><p>在本文中，我们将区分两种类型的函数。</p>
<p><strong>纯函数</strong>。函数有一些输入（它们的参数）并返回一些输出（应用它们的结果）。内置函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以被描述为一台接受输入并产生输出的小型机器。</p>
<p><img src="https://www.composingprograms.com/img/function_abs.png" alt="img"></p>
<p>函数 <code>abs</code> 是纯的。纯函数具有这样的属性，即应用它们除了返回值之外没有任何影响。此外，当使用相同的参数调用两次时，纯函数必须始终返回相同的值。</p>
<p><strong>非纯函数</strong>。除了返回值之外，应用非纯函数还会产生副作用，从而对解释器或计算机的状态进行一些更改。一个常见的副作用是使用该 <code>print</code> 函数生成超出返回值的其他输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>虽然 在这些示例中<code>print</code>和<code>abs</code>可能看起来很相似，但它们的工作方式却截然不同。<code>print</code> 返回的值始终是<code>None</code>，一个不表示任何内容的特殊 Python 值。交互式 Python 解释器不会自动打印值 <code>None</code> 。在<code>print</code>的情况下，函数本身是打印输出作为被调用的副作用。</p>
<p><img src="https://www.composingprograms.com/img/function_print.png" alt="img"></p>
<p>调用的嵌套表达式，以 <code>print</code> 突出显示函数的非纯字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">print</span>(<span class="number">1</span>), <span class="built_in">print</span>(<span class="number">2</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">None</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>小心 <code>print</code> ！它返回 <code>None</code> 的事实意味着它不应该是赋值语句中的表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>two = <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(two)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>纯函数受到限制，因为它们不能产生副作用或随时间改变行为。实施这些限制会产生巨大的好处。首先，纯函数可以更可靠地组合成复合调用表达式。我们可以在上面的非纯函数示例中看到， <code>print</code> 在操作数表达式中使用时不会返回有用的结果。另一方面，我们已经看到 <code>max</code> ， <code>pow</code> 像 和 <code>sqrt</code> 这样的函数可以在嵌套表达式中有效地使用。</p>
<p>其次，纯函数往往更容易测试。参数列表将始终导致相同的返回值，该值可以与预期的返回值进行比较。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mxkgf.github.io/2024/04/02/%E8%B0%83%E8%AF%95%E7%9A%84%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="马晓康">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/02/%E8%B0%83%E8%AF%95%E7%9A%84%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">调试的指导原则</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-02 13:49:00" itemprop="dateCreated datePublished" datetime="2024-04-02T13:49:00+08:00">2024-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-04-03 11:40:58" itemprop="dateModified" datetime="2024-04-03T11:40:58+08:00">2024-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="调试的指导原则"><a href="#调试的指导原则" class="headerlink" title="调试的指导原则"></a>调试的指导原则</h2><ol>
<li><p><strong>增量测试</strong>：每个编写良好的程序都由可以单独测试的小型模块化组件组成。尽快尝试您编写的所有内容，以便及早发现问题并获得对组件的信心。</p>
</li>
<li><p><strong>隔离错误</strong>：语句输出中的错误通常可归因于特定的模块化组件。尝试诊断问题时，请先将错误跟踪到最小的代码片段，然后再尝试更正错误。</p>
</li>
<li><p><strong>检查你的假设</strong>：解释器确实不折不扣地执行你的指示——不多也不少。当某些代码的行为与你认为的行为不匹配时，检查您的假设，然后将调试工作重点放在验证您的假设是否确实成立上。</p>
</li>
<li><p><strong>咨询他人</strong>：如果您不理解错误消息，请咨询朋友、教师或搜索引擎。如果您已经隔离了一个错误，但不知道如何纠正它，请让其他人查看。</p>
<blockquote>
<p><strong>希望增量测试、模块化设计、精确的假设和团队合作能贯穿您的整个计算机科学生涯。</strong></p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mxkgf.github.io/2024/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="马晓康">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="天行健，君子以自强不息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/" class="post-title-link" itemprop="url">计算机系统漫游</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-02-10 11:13:00" itemprop="dateCreated datePublished" datetime="2024-02-10T11:13:00+08:00">2024-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-04-02 19:01:43" itemprop="dateModified" datetime="2024-04-02T19:01:43+08:00">2024-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Amdahl定理"><a href="#Amdahl定理" class="headerlink" title="Amdahl定理"></a><a href="Amdahl定理">Amdahl定理</a></h3><blockquote>
<p>当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</p>
</blockquote>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ol>
<li>线程级并发</li>
<li>指令级并行</li>
<li>单指令、多数据并行</li>
</ol>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol>
<li>并发 (concurrency)指一个同时具有多个活动的系统;</li>
<li>并行 (parallelism)指的是用并发来使一个系统运行得更快</li>
</ol>
<h3 id="计算机系统中抽象的重要性"><a href="#计算机系统中抽象的重要性" class="headerlink" title="计算机系统中抽象的重要性"></a>计算机系统中抽象的重要性</h3><ol>
<li>文件是对<code>I/0</code>设备的抽象</li>
<li>虚拟内存是对程序存储器的抽象</li>
<li>进程是对一个正在运行的程序的抽象</li>
<li>虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2021 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">马晓康</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"mhchem":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
